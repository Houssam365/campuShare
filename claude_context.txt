File: src/main/java/com/campusshare/test/TestAnnonceFeatures.java
package com.campusshare.test;

import com.campusshare.factory.AnnonceFactory;
import com.campusshare.model.Categorie;
import com.campusshare.model.Etudiant;
import com.campusshare.model.StatutAnnonce;
import com.campusshare.model.Utilisateur;
import com.campusshare.model.annonce.Annonce;
import com.campusshare.model.annonce.BienAnnonce;
import com.campusshare.model.annonce.DonAnnonce;
import com.campusshare.model.annonce.ServiceAnnonce;
import com.campusshare.model.annonce.TypeAnnonce;
import com.campusshare.observer.Observer;

/**
 * Classe de test pour vÃ©rifier l'implÃ©mentation des tickets T2-01, T2-02 et T2-03.
 * 
 * T2-01: Annonce Hierarchy (Bien with price, Don with price 0)
 * T2-02: Factory Pattern (creerAnnonce returns correct type, Title validation)
 * T2-03: Observer Integration (attach, notify)
 */
public class TestAnnonceFeatures {

    // Mock Observer pour T2-03
    static class MockObserver implements Observer {
        private boolean notified = false;
        private String lastMessage = "";

        @Override
        public void update(Annonce annonce, String message) {
            this.notified = true;
            this.lastMessage = message;
            System.out.println("âœ… [Observer] Notification reÃ§ue pour l'annonce: " + annonce.getTitre() + " - Message: " + message);
        }

        public boolean isNotified() {
            return notified;
        }

        public String getLastMessage() {
            return lastMessage;
        }
    }

    public static void main(String[] args) {
        System.out.println("=================================================");
        System.out.println("  DÃ©marrage des tests pour les tickets T2-01 Ã  T2-03");
        System.out.println("=================================================");

        // PrÃ©paration des donnÃ©es de base
        Etudiant auteur = new Etudiant("E001", "Dupont", "Alice", "alice.dupont@campus.fr", "pass123", "12345", "Campus Ouest");
        Categorie categorieLivre = new Categorie("C01", "Livres", "Livres et manuels", "ğŸ“š");
        Categorie categorieAide = new Categorie("C02", "Aide", "Aide aux devoirs, tutorat", "ğŸ§ ");

        // -----------------------------------------------------------------
        // T2-02: Test de la Factory et de la validation du titre
        // -----------------------------------------------------------------
        System.out.println("\n--- T2-02: Test de la Factory et de la validation ---");

        // Test 2.1: CrÃ©ation d'une BienAnnonce
        Annonce bienAnnonce = AnnonceFactory.creerAnnonce(TypeAnnonce.BIEN, "VÃ©lo de ville", "VÃ©lo en bon Ã©tat", auteur, categorieLivre);
        assert bienAnnonce instanceof BienAnnonce : "âŒ T2-02.1: La Factory n'a pas retournÃ© BienAnnonce pour le type BIEN.";
        System.out.println("âœ… T2-02.1: Factory retourne BienAnnonce.");

        // Test 2.2: CrÃ©ation d'une ServiceAnnonce
        Annonce serviceAnnonce = AnnonceFactory.creerAnnonce(TypeAnnonce.SERVICE, "Cours de Java", "Tutorat pour dÃ©butants", auteur, categorieAide);
        assert serviceAnnonce instanceof ServiceAnnonce : "âŒ T2-02.2: La Factory n'a pas retournÃ© ServiceAnnonce pour le type SERVICE.";
        System.out.println("âœ… T2-02.2: Factory retourne ServiceAnnonce.");

        // Test 2.3: CrÃ©ation d'une DonAnnonce (Acceptance T2-02)
        Annonce donAnnonce = AnnonceFactory.creerAnnonce(TypeAnnonce.DON, "Cahiers neufs", "Lot de cahiers neufs", auteur, categorieLivre);
        assert donAnnonce instanceof DonAnnonce : "âŒ T2-02.3: La Factory n'a pas retournÃ© DonAnnonce pour le type DON.";
        System.out.println("âœ… T2-02.3: Factory retourne DonAnnonce (Acceptance T2-02 OK).");

        // Test 2.4: Validation du titre (T2-02)
        try {
            AnnonceFactory.creerAnnonce(TypeAnnonce.BIEN, "", "Description", auteur, categorieLivre);
            System.out.println("âŒ T2-02.4: La validation du titre n'a pas fonctionnÃ© (pas d'exception levÃ©e).");
        } catch (IllegalArgumentException e) {
            if (e.getMessage().contains("Le titre de l'annonce ne peut pas Ãªtre vide.")) {
                System.out.println("âœ… T2-02.4: Validation du titre OK. Exception levÃ©e: " + e.getMessage());
            } else {
                System.out.println("âŒ T2-02.4: Validation du titre a levÃ© une mauvaise exception: " + e.getMessage());
            }
        }

        // -----------------------------------------------------------------
        // T2-01: Test de l'Annonce Hierarchy (Prix)
        // -----------------------------------------------------------------
        System.out.println("\n--- T2-01: Test de l'Annonce Hierarchy (Prix) ---");

        // Test 1.1: BienAnnonce avec prix (Acceptance T2-01)
        BienAnnonce bienAnnoncePrix = AnnonceFactory.creerAnnonceBien("Livre de Maths", "Manuel d'analyse", auteur, categorieLivre, "Neuf", 15.50);
        assert bienAnnoncePrix.getPrixBase() == 15.50 : "âŒ T2-01.1: BienAnnonce n'a pas le prix correct. Attendu: 15.50, Obtenu: " + bienAnnoncePrix.getPrixBase();
        System.out.println("âœ… T2-01.1: BienAnnonce peut Ãªtre instanciÃ©e avec un prix (Acceptance T2-01 OK). Prix: " + bienAnnoncePrix.getPrixBase());

        // Test 1.2: DonAnnonce avec prix 0 (Acceptance T2-01)
        DonAnnonce donAnnoncePrix = AnnonceFactory.creerAnnonceDon("Vieux T-Shirt", "Ã€ donner", auteur, categorieLivre, "UsÃ©", "DÃ©mÃ©nagement");
        assert donAnnoncePrix.getPrixBase() == 0.0 : "âŒ T2-01.2: DonAnnonce n'a pas le prix 0. Attendu: 0.0, Obtenu: " + donAnnoncePrix.getPrixBase();
        System.out.println("âœ… T2-01.2: DonAnnonce est instanciÃ©e avec prix 0 (Acceptance T2-01 OK). Prix: " + donAnnoncePrix.getPrixBase());

        // -----------------------------------------------------------------
        // T2-03: Test de l'intÃ©gration de l'Observer
        // -----------------------------------------------------------------
        System.out.println("\n--- T2-03: Test de l'intÃ©gration de l'Observer ---");

        // Test 3.1: Attacher et notifier (Acceptance T2-03)
        MockObserver mockObserver = new MockObserver();
        bienAnnoncePrix.attach(mockObserver);
        System.out.println("   [Test] Attachement de l'Observer Ã  l'annonce.");

        // Changement de statut qui notifie automatiquement
        bienAnnoncePrix.changerStatut(StatutAnnonce.RESERVEE);
        
        assert mockObserver.isNotified() : "âŒ T2-03.1: L'Observer n'a pas Ã©tÃ© notifiÃ© aprÃ¨s le changement de statut.";
        assert mockObserver.getLastMessage().contains("passÃ©e de ACTIVE Ã  RESERVEE") : "âŒ T2-03.1: Le message de notification est incorrect.";
        System.out.println("âœ… T2-03.1: L'Observer a Ã©tÃ© notifiÃ© aprÃ¨s changerStatut (Acceptance T2-03 OK).");

        // Test 3.2: Notification via setTitre
        mockObserver.notified = false; // Reset
        bienAnnoncePrix.setTitre("Nouveau Titre du Livre");
        assert mockObserver.isNotified() : "âŒ T2-03.2: L'Observer n'a pas Ã©tÃ© notifiÃ© aprÃ¨s setTitre.";
        assert mockObserver.getLastMessage().contains("Le titre de l'annonce a Ã©tÃ© modifiÃ©") : "âŒ T2-03.2: Le message de notification setTitre est incorrect.";
        System.out.println("âœ… T2-03.2: L'Observer a Ã©tÃ© notifiÃ© aprÃ¨s setTitre.");
        
        // Test 3.3: DÃ©tacher l'Observer
        bienAnnoncePrix.detach(mockObserver);
        mockObserver.notified = false; // Reset
        bienAnnoncePrix.setTitre("Titre Final"); // Devrait notifier, mais l'observer est dÃ©tachÃ©
        assert !mockObserver.isNotified() : "âŒ T2-03.3: L'Observer a Ã©tÃ© notifiÃ© aprÃ¨s avoir Ã©tÃ© dÃ©tachÃ©.";
        System.out.println("âœ… T2-03.3: L'Observer a Ã©tÃ© dÃ©tachÃ© et n'a pas Ã©tÃ© notifiÃ©.");


        System.out.println("\n=================================================");
        System.out.println("  Tous les tests pour T2-01, T2-02 et T2-03 sont terminÃ©s.");
        System.out.println("=================================================");
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/observer/SMSObserver.java
package com.campusshare.observer;

import com.campusshare.model.Utilisateur;
import com.campusshare.model.annonce.Annonce;

/**
 * Observateur concret qui envoie des notifications par SMS.
 * ImplÃ©mentation du pattern Observer.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class SMSObserver implements Observer {
    
    private Utilisateur utilisateur;
    private String numeroTelephone;
    
    /**
     * Constructeur de l'observateur SMS.
     * 
     * @param utilisateur L'utilisateur qui recevra les SMS
     * @param numeroTelephone NumÃ©ro de tÃ©lÃ©phone de l'utilisateur
     */
    public SMSObserver(Utilisateur utilisateur, String numeroTelephone) {
        this.utilisateur = utilisateur;
        this.numeroTelephone = numeroTelephone;
    }
    
    /**
     * Envoie une notification par SMS Ã  l'utilisateur.
     * (Simulation - en production, utiliserait Twilio ou similaire)
     * 
     * @param annonce L'annonce concernÃ©e
     * @param message Le message de notification
     */
    @Override
    public void update(Annonce annonce, String message) {
        // Simulation d'envoi de SMS
        System.out.println("ğŸ’¬ SMS envoyÃ© au " + numeroTelephone);
        System.out.println("   Message: CampusShare - " + truncate(message, 100));
        System.out.println();
    }
    
    /**
     * Tronque le message si nÃ©cessaire (limite SMS).
     */
    private String truncate(String message, int maxLength) {
        if (message.length() <= maxLength) {
            return message;
        }
        return message.substring(0, maxLength - 3) + "...";
    }
    
    public Utilisateur getUtilisateur() {
        return utilisateur;
    }
    
    public void setUtilisateur(Utilisateur utilisateur) {
        this.utilisateur = utilisateur;
    }
    
    public String getNumeroTelephone() {
        return numeroTelephone;
    }
    
    public void setNumeroTelephone(String numeroTelephone) {
        this.numeroTelephone = numeroTelephone;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/observer/Observable.java
package com.campusshare.observer;

/**
 * Interface Observable (Subject) du pattern Observer.
 * 
 * Permet Ã  un objet de notifier automatiquement tous ses observateurs
 * lorsqu'un changement d'Ã©tat se produit.
 * 
 * Dans CampusShare, les annonces sont des Observables qui notifient
 * les utilisateurs intÃ©ressÃ©s lors de changements.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public interface Observable {
    
    /**
     * Attache un observateur Ã  cet observable.
     * L'observateur sera notifiÃ© lors des changements.
     * 
     * @param observer L'observateur Ã  attacher
     */
    void attach(Observer observer);
    
    /**
     * DÃ©tache un observateur de cet observable.
     * L'observateur ne recevra plus de notifications.
     * 
     * @param observer L'observateur Ã  dÃ©tacher
     */
    void detach(Observer observer);
    
    /**
     * Notifie tous les observateurs attachÃ©s d'un changement.
     * 
     * @param message Le message dÃ©crivant le changement
     */
    void notifyObservers(String message);
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/observer/EmailObserver.java
package com.campusshare.observer;

import com.campusshare.model.Utilisateur;
import com.campusshare.model.annonce.Annonce;

/**
 * Observateur concret qui envoie des notifications par email.
 * ImplÃ©mentation du pattern Observer.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class EmailObserver implements Observer {
    
    private Utilisateur utilisateur;
    
    /**
     * Constructeur de l'observateur email.
     * 
     * @param utilisateur L'utilisateur qui recevra les emails
     */
    public EmailObserver(Utilisateur utilisateur) {
        this.utilisateur = utilisateur;
    }
    
    /**
     * Envoie une notification par email Ã  l'utilisateur.
     * (Simulation - en production, utiliserait une API email)
     * 
     * @param annonce L'annonce concernÃ©e
     * @param message Le message de notification
     */
    @Override
    public void update(Annonce annonce, String message) {
        // Simulation d'envoi d'email
        System.out.println("ğŸ“§ EMAIL envoyÃ© Ã  " + utilisateur.getEmail());
        System.out.println("   Sujet: [CampusShare] Notification - " + annonce.getTitre());
        System.out.println("   Message: " + message);
        System.out.println();
    }
    
    public Utilisateur getUtilisateur() {
        return utilisateur;
    }
    
    public void setUtilisateur(Utilisateur utilisateur) {
        this.utilisateur = utilisateur;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/observer/Observer.java
package com.campusshare.observer;

import com.campusshare.model.annonce.Annonce;

/**
 * Interface Observer du pattern Observer.
 * 
 * Les classes qui implÃ©mentent cette interface peuvent s'abonner
 * Ã  des Observables et recevoir des notifications de changement.
 * 
 * Dans CampusShare, diffÃ©rents types de notifications peuvent Ãªtre
 * implÃ©mentÃ©s: Email, Push, SMS, etc.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public interface Observer {
    
    /**
     * MÃ©thode appelÃ©e lorsqu'un Observable notifie ses observateurs.
     * 
     * @param annonce L'annonce qui a changÃ©
     * @param message Le message dÃ©crivant le changement
     */
    void update(Annonce annonce, String message);
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/observer/PushObserver.java
package com.campusshare.observer;

import com.campusshare.model.Utilisateur;
import com.campusshare.model.annonce.Annonce;

/**
 * Observateur concret qui envoie des notifications push.
 * ImplÃ©mentation du pattern Observer.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class PushObserver implements Observer {
    
    private Utilisateur utilisateur;
    private String deviceToken; // Token du device mobile
    
    /**
     * Constructeur de l'observateur push.
     * 
     * @param utilisateur L'utilisateur qui recevra les notifications push
     */
    public PushObserver(Utilisateur utilisateur) {
        this.utilisateur = utilisateur;
        this.deviceToken = "DEVICE_" + utilisateur.getId();
    }
    
    /**
     * Envoie une notification push Ã  l'utilisateur.
     * (Simulation - en production, utiliserait Firebase/APNs)
     * 
     * @param annonce L'annonce concernÃ©e
     * @param message Le message de notification
     */
    @Override
    public void update(Annonce annonce, String message) {
        // Simulation d'envoi de notification push
        System.out.println("ğŸ“± PUSH envoyÃ© Ã  " + utilisateur.getNomComplet());
        System.out.println("   Device: " + deviceToken);
        System.out.println("   Titre: " + annonce.getTitre());
        System.out.println("   Corps: " + message);
        System.out.println();
    }
    
    public Utilisateur getUtilisateur() {
        return utilisateur;
    }
    
    public void setUtilisateur(Utilisateur utilisateur) {
        this.utilisateur = utilisateur;
    }
    
    public String getDeviceToken() {
        return deviceToken;
    }
    
    public void setDeviceToken(String deviceToken) {
        this.deviceToken = deviceToken;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/adapter/GoogleCalendarAPI.java
package com.campusshare.adapter;

import java.time.LocalDateTime;

/**
 * Classe simulant l'API Google Calendar (systÃ¨me externe).
 * Cette classe reprÃ©sente une API tierce avec sa propre interface.
 * 
 * Pattern Adapter: C'est la classe "AdaptÃ©e" - elle a une interface
 * incompatible avec celle attendue par notre application.
 * 
 * En production, cette classe reprÃ©senterait l'API rÃ©elle de Google Calendar.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class GoogleCalendarAPI {
    
    private String apiKey;
    private String calendarId;
    
    /**
     * Constructeur de l'API Google Calendar.
     * 
     * @param apiKey ClÃ© API Google
     * @param calendarId ID du calendrier
     */
    public GoogleCalendarAPI(String apiKey, String calendarId) {
        this.apiKey = apiKey;
        this.calendarId = calendarId;
    }
    
    /**
     * CrÃ©e un Ã©vÃ©nement dans Google Calendar.
     * Interface spÃ©cifique Ã  Google (diffÃ©rente de notre interface Calendrier).
     * 
     * @param eventTitle Titre de l'Ã©vÃ©nement
     * @param startTime Heure de dÃ©but
     * @param endTime Heure de fin
     * @param description Description
     * @param location Lieu
     * @return ID de l'Ã©vÃ©nement crÃ©Ã©, ou null si Ã©chec
     */
    public String createEvent(String eventTitle, LocalDateTime startTime, 
                              LocalDateTime endTime, String description, String location) {
        // Simulation de l'appel Ã  l'API Google
        System.out.println("  [GoogleCalendarAPI] CrÃ©ation d'Ã©vÃ©nement...");
        System.out.println("    â†’ Calendrier: " + calendarId);
        System.out.println("    â†’ Titre: " + eventTitle);
        System.out.println("    â†’ DÃ©but: " + startTime);
        System.out.println("    â†’ Fin: " + endTime);
        
        // Simulation: gÃ©nÃ¨re un ID d'Ã©vÃ©nement Google
        String eventId = "gcal_" + System.currentTimeMillis();
        System.out.println("    â†’ Ã‰vÃ©nement crÃ©Ã© avec ID: " + eventId);
        
        return eventId;
    }
    
    /**
     * Supprime un Ã©vÃ©nement de Google Calendar.
     * 
     * @param eventId ID de l'Ã©vÃ©nement Google
     * @return true si la suppression a rÃ©ussi
     */
    public boolean deleteEvent(String eventId) {
        System.out.println("  [GoogleCalendarAPI] Suppression de l'Ã©vÃ©nement: " + eventId);
        // Simulation
        return true;
    }
    
    /**
     * Met Ã  jour un Ã©vÃ©nement existant.
     * 
     * @param eventId ID de l'Ã©vÃ©nement
     * @param eventTitle Nouveau titre
     * @param startTime Nouvelle heure de dÃ©but
     * @param endTime Nouvelle heure de fin
     * @return true si la mise Ã  jour a rÃ©ussi
     */
    public boolean updateEvent(String eventId, String eventTitle, 
                               LocalDateTime startTime, LocalDateTime endTime) {
        System.out.println("  [GoogleCalendarAPI] Mise Ã  jour de l'Ã©vÃ©nement: " + eventId);
        System.out.println("    â†’ Nouveau titre: " + eventTitle);
        // Simulation
        return true;
    }
    
    /**
     * VÃ©rifie si un crÃ©neau est libre dans le calendrier.
     * 
     * @param startTime DÃ©but du crÃ©neau
     * @param endTime Fin du crÃ©neau
     * @return true si le crÃ©neau est libre
     */
    public boolean checkAvailability(LocalDateTime startTime, LocalDateTime endTime) {
        System.out.println("  [GoogleCalendarAPI] VÃ©rification de disponibilitÃ©...");
        System.out.println("    â†’ De: " + startTime + " Ã  " + endTime);
        // Simulation: toujours disponible
        return true;
    }
    
    // Getters
    
    public String getApiKey() {
        return apiKey;
    }
    
    public String getCalendarId() {
        return calendarId;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/adapter/Calendrier.java
package com.campusshare.adapter;

import com.campusshare.model.Reservation;

/**
 * Interface cible pour la gestion des calendriers.
 * DÃ©finit les opÃ©rations que l'application attend d'un calendrier.
 * 
 * Pattern Adapter: Cette interface reprÃ©sente le contrat que notre
 * application utilise, indÃ©pendamment de l'implÃ©mentation concrÃ¨te
 * du systÃ¨me de calendrier externe.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public interface Calendrier {
    
    /**
     * Ajoute une rÃ©servation au calendrier.
     * 
     * @param reservation La rÃ©servation Ã  ajouter
     * @return true si l'ajout a rÃ©ussi
     */
    boolean ajouterEvenement(Reservation reservation);
    
    /**
     * Supprime une rÃ©servation du calendrier.
     * 
     * @param reservationId L'ID de la rÃ©servation Ã  supprimer
     * @return true si la suppression a rÃ©ussi
     */
    boolean supprimerEvenement(String reservationId);
    
    /**
     * Modifie une rÃ©servation existante.
     * 
     * @param reservation La rÃ©servation modifiÃ©e
     * @return true si la modification a rÃ©ussi
     */
    boolean modifierEvenement(Reservation reservation);
    
    /**
     * VÃ©rifie si un crÃ©neau est disponible.
     * 
     * @param reservation La rÃ©servation Ã  vÃ©rifier
     * @return true si le crÃ©neau est disponible
     */
    boolean verifierDisponibilite(Reservation reservation);
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/adapter/GoogleCalendarAdapter.java
package com.campusshare.adapter;

import com.campusshare.model.Reservation;

import java.util.HashMap;
import java.util.Map;

/**
 * Adaptateur pour Google Calendar.
 * 
 * Pattern Adapter: Cette classe adapte l'interface de GoogleCalendarAPI
 * (systÃ¨me externe) Ã  notre interface Calendrier (attendue par l'application).
 * 
 * Fonctionnement:
 * - Notre application utilise l'interface Calendrier
 * - L'adaptateur traduit les appels vers l'API Google
 * - Conversion des objets Reservation vers les paramÃ¨tres Google
 * 
 * Avantages:
 * - DÃ©couplage: notre code ne dÃ©pend pas directement de l'API Google
 * - FacilitÃ© de changement: on peut remplacer Google par un autre calendrier
 * - TestabilitÃ©: on peut mocker l'interface Calendrier
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class GoogleCalendarAdapter implements Calendrier {
    
    private GoogleCalendarAPI googleCalendarAPI; // L'adaptÃ©e
    private Map<String, String> mappingIds; // reservationId -> googleEventId
    
    /**
     * Constructeur de l'adaptateur.
     * 
     * @param googleCalendarAPI L'API Google Ã  adapter
     */
    public GoogleCalendarAdapter(GoogleCalendarAPI googleCalendarAPI) {
        this.googleCalendarAPI = googleCalendarAPI;
        this.mappingIds = new HashMap<>();
    }
    
    /**
     * Constructeur simplifiÃ© avec crÃ©ation de l'API.
     * 
     * @param apiKey ClÃ© API Google
     * @param calendarId ID du calendrier
     */
    public GoogleCalendarAdapter(String apiKey, String calendarId) {
        this(new GoogleCalendarAPI(apiKey, calendarId));
    }
    
    /**
     * Adapte l'ajout d'une rÃ©servation vers l'API Google.
     * Convertit une Reservation en paramÃ¨tres d'Ã©vÃ©nement Google.
     */
    @Override
    public boolean ajouterEvenement(Reservation reservation) {
        System.out.println("ğŸ—“ï¸ [Adapter] Ajout d'une rÃ©servation au calendrier Google...");
        
        // Conversion Reservation â†’ paramÃ¨tres Google
        String titre = "CampusShare: " + reservation.getAnnonce().getTitre();
        String description = String.format(
                "RÃ©servation #%s\n" +
                "Demandeur: %s\n" +
                "PropriÃ©taire: %s\n" +
                "Prix: %.2fâ‚¬",
                reservation.getId(),
                reservation.getDemandeur().getNomComplet(),
                reservation.getProprietaire().getNomComplet(),
                reservation.getPrixTotal()
        );
        String localisation = reservation.getAnnonce().getLocalisation();
        
        // Appel Ã  l'API Google via l'adaptÃ©e
        String googleEventId = googleCalendarAPI.createEvent(
                titre,
                reservation.getDateDebut(),
                reservation.getDateFin(),
                description,
                localisation
        );
        
        if (googleEventId != null) {
            // MÃ©moriser le mapping pour les futures opÃ©rations
            mappingIds.put(reservation.getId(), googleEventId);
            return true;
        }
        
        return false;
    }
    
    /**
     * Adapte la suppression d'une rÃ©servation du calendrier Google.
     */
    @Override
    public boolean supprimerEvenement(String reservationId) {
        System.out.println("ğŸ—“ï¸ [Adapter] Suppression de la rÃ©servation du calendrier...");
        
        String googleEventId = mappingIds.get(reservationId);
        if (googleEventId == null) {
            System.out.println("  âš ï¸ Ã‰vÃ©nement non trouvÃ© dans le mapping");
            return false;
        }
        
        boolean success = googleCalendarAPI.deleteEvent(googleEventId);
        if (success) {
            mappingIds.remove(reservationId);
        }
        return success;
    }
    
    /**
     * Adapte la modification d'une rÃ©servation.
     */
    @Override
    public boolean modifierEvenement(Reservation reservation) {
        System.out.println("ğŸ—“ï¸ [Adapter] Modification de l'Ã©vÃ©nement...");
        
        String googleEventId = mappingIds.get(reservation.getId());
        if (googleEventId == null) {
            // L'Ã©vÃ©nement n'existe pas, on le crÃ©e
            return ajouterEvenement(reservation);
        }
        
        String titre = "CampusShare: " + reservation.getAnnonce().getTitre();
        
        return googleCalendarAPI.updateEvent(
                googleEventId,
                titre,
                reservation.getDateDebut(),
                reservation.getDateFin()
        );
    }
    
    /**
     * Adapte la vÃ©rification de disponibilitÃ©.
     */
    @Override
    public boolean verifierDisponibilite(Reservation reservation) {
        System.out.println("ğŸ—“ï¸ [Adapter] VÃ©rification de disponibilitÃ©...");
        
        return googleCalendarAPI.checkAvailability(
                reservation.getDateDebut(),
                reservation.getDateFin()
        );
    }
    
    /**
     * Retourne l'API Google (pour tests ou configuration).
     */
    public GoogleCalendarAPI getGoogleCalendarAPI() {
        return googleCalendarAPI;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/CampusShareApp.java
package com.campusshare;

import com.campusshare.adapter.GoogleCalendarAdapter;
import com.campusshare.factory.AnnonceFactory;
import com.campusshare.model.*;
import com.campusshare.model.annonce.*;
import com.campusshare.observer.*;
import com.campusshare.service.*;
import com.campusshare.strategy.*;

import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *                            CAMPUS SHARE
 *          Application de partage de biens et services entre Ã©tudiants
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * Cette application dÃ©montre l'utilisation de 4 Design Patterns:
 * 
 * 1. SIMPLE FACTORY (AnnonceFactory)
 *    â†’ CrÃ©ation centralisÃ©e des diffÃ©rents types d'annonces
 *    
 * 2. OBSERVER (Observable/Observer)
 *    â†’ SystÃ¨me de notifications pour les changements d'annonces
 *    
 * 3. STRATEGY (StrategyTarification)
 *    â†’ Calcul flexible du prix selon diffÃ©rentes stratÃ©gies
 *    
 * 4. ADAPTER (GoogleCalendarAdapter)
 *    â†’ IntÃ©gration avec des systÃ¨mes de calendrier externes
 * 
 * @author Equipe CampusShare - INFO 732
 * @version 1.0
 */
public class CampusShareApp {
    
    // Services
    private AnnonceService annonceService;
    private ReservationService reservationService;
    private EvaluationService evaluationService;
    
    // DonnÃ©es de dÃ©monstration
    private List<Categorie> categories;
    private List<Utilisateur> utilisateurs;
    
    /**
     * Constructeur - initialise les services.
     */
    public CampusShareApp() {
        this.annonceService = new AnnonceService();
        this.evaluationService = new EvaluationService();
        
        // CrÃ©ation du calendrier avec l'adaptateur
        GoogleCalendarAdapter calendrierAdapter = new GoogleCalendarAdapter(
                "API_KEY_DEMO", "campusshare_calendar");
        this.reservationService = new ReservationService(calendrierAdapter);
        
        // Initialisation des donnÃ©es
        initialiserCategories();
        initialiserUtilisateurs();
    }
    
    /**
     * Point d'entrÃ©e de l'application.
     */
    public static void main(String[] args) {
        System.out.println("\n" +
                "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n" +
                "â•‘                                                                       â•‘\n" +
                "â•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—               â•‘\n" +
                "â•‘    â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•               â•‘\n" +
                "â•‘    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—               â•‘\n" +
                "â•‘    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘               â•‘\n" +
                "â•‘    â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘               â•‘\n" +
                "â•‘     â•šâ•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•      â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•               â•‘\n" +
                "â•‘                                                                       â•‘\n" +
                "â•‘              â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                 â•‘\n" +
                "â•‘              â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•                 â•‘\n" +
                "â•‘              â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                   â•‘\n" +
                "â•‘              â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•                   â•‘\n" +
                "â•‘              â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                 â•‘\n" +
                "â•‘              â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•                 â•‘\n" +
                "â•‘                                                                       â•‘\n" +
                "â•‘         Application de partage entre Ã©tudiants - INFO 732            â•‘\n" +
                "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
        
        CampusShareApp app = new CampusShareApp();
        app.executerDemonstration();
    }
    
    /**
     * ExÃ©cute une dÃ©monstration complÃ¨te des fonctionnalitÃ©s.
     */
    public void executerDemonstration() {
        System.out.println("\nğŸ“‹ DÃ‰MONSTRATION DES DESIGN PATTERNS\n");
        System.out.println("â•".repeat(70));
        
        // 1. DÃ©monstration Simple Factory
        demonstrationFactory();
        
        // 2. DÃ©monstration Observer
        demonstrationObserver();
        
        // 3. DÃ©monstration Strategy
        demonstrationStrategy();
        
        // 4. DÃ©monstration Adapter
        demonstrationAdapter();
        
        // 5. ScÃ©nario complet
        demonstrationScenarioComplet();
        
        // RÃ©sumÃ© final
        afficherResume();
    }
    
    /**
     * DÃ©monstration du Pattern SIMPLE FACTORY.
     */
    private void demonstrationFactory() {
        System.out.println("\n" +
                "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n" +
                "â”‚  ğŸ­ PATTERN SIMPLE FACTORY - CrÃ©ation d'annonces                    â”‚\n" +
                "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");
        
        Utilisateur alice = utilisateurs.get(0);
        Utilisateur bob = utilisateurs.get(1);
        Utilisateur charlie = utilisateurs.get(2);
        
        System.out.println("La Factory permet de crÃ©er diffÃ©rents types d'annonces");
        System.out.println("sans que le code client connaisse les classes concrÃ¨tes.\n");
        
        // CrÃ©ation via la Factory
        System.out.println("â†’ CrÃ©ation d'une annonce de BIEN (vÃ©lo):");
        BienAnnonce annonceBien = annonceService.publierBien(
                "VÃ©lo VTT Rockrider",
                "VTT Rockrider 520, idÃ©al pour se dÃ©placer sur le campus. " +
                "Freins Ã  disque, 21 vitesses.",
                alice,
                categories.get(0), // Transport
                "Bon Ã©tat",
                5.0 // 5â‚¬/jour
        );
        annonceBien.setMarque("Rockrider");
        annonceBien.setMontantCaution(50.0);
        annonceBien.setLocalisation("RÃ©sidence A, BÃ¢timent 3");
        
        System.out.println("\nâ†’ CrÃ©ation d'une annonce de SERVICE (cours de maths):");
        ServiceAnnonce annonceService = this.annonceService.publierService(
                "Cours particuliers de MathÃ©matiques",
                "Ã‰tudiant en L3 Maths, je propose des cours de soutien en algÃ¨bre " +
                "et analyse. Tous niveaux jusqu'Ã  L2.",
                bob,
                categories.get(3), // Ã‰tudes
                "Tutorat",
                15.0, // 15â‚¬/heure
                60    // 60 minutes
        );
        annonceService.setNiveauExpertise("Expert");
        annonceService.ajouterJourDisponible(DayOfWeek.MONDAY);
        annonceService.ajouterJourDisponible(DayOfWeek.WEDNESDAY);
        annonceService.ajouterJourDisponible(DayOfWeek.FRIDAY);
        annonceService.setHoraireDisponible("14h-19h");
        annonceService.ajouterCompetence("AlgÃ¨bre linÃ©aire");
        annonceService.ajouterCompetence("Analyse rÃ©elle");
        
        System.out.println("\nâ†’ CrÃ©ation d'une annonce de DON (livres):");
        DonAnnonce annonceDon = this.annonceService.publierDon(
                "Livres d'informatique L1/L2",
                "Je donne mes anciens livres: Introduction Ã  Java, " +
                "Algorithmique, Bases de donnÃ©es.",
                charlie,
                categories.get(3), // Ã‰tudes
                "TrÃ¨s bon Ã©tat",
                "Fin d'Ã©tudes"
        );
        annonceDon.setQuantiteDisponible(3);
        annonceDon.setConditionsRecuperation("Ã€ rÃ©cupÃ©rer Ã  la BU, contactez-moi pour RDV");
        
        System.out.println("\nğŸ“Š RÃ©sultat de la Factory:");
        System.out.println("   " + this.annonceService.getNombreAnnonces() + " annonces crÃ©Ã©es");
        System.out.println("   Types: BIEN, SERVICE, DON - tous crÃ©Ã©s via AnnonceFactory\n");
    }
    
    /**
     * DÃ©monstration du Pattern OBSERVER.
     */
    private void demonstrationObserver() {
        System.out.println("\n" +
                "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n" +
                "â”‚  ğŸ‘ï¸ PATTERN OBSERVER - SystÃ¨me de notifications                     â”‚\n" +
                "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");
        
        System.out.println("Le pattern Observer permet de notifier automatiquement");
        System.out.println("les utilisateurs intÃ©ressÃ©s lors de changements.\n");
        
        Utilisateur diana = utilisateurs.get(3);
        Annonce annonce = annonceService.getAnnonces().get(0); // Le vÃ©lo
        
        // CrÃ©ation d'observateurs
        System.out.println("â†’ Diana s'abonne aux notifications pour le vÃ©lo:\n");
        
        EmailObserver emailObs = new EmailObserver(diana);
        PushObserver pushObs = new PushObserver(diana);
        SMSObserver smsObs = new SMSObserver(diana, "06 12 34 56 78");
        
        // Attachement des observateurs
        annonce.attach(emailObs);
        annonce.attach(pushObs);
        annonce.attach(smsObs);
        
        System.out.println("â†’ Le propriÃ©taire modifie le prix de l'annonce:\n");
        annonce.setPrixBase(4.0); // Modification qui dÃ©clenche les notifications
        
        System.out.println("â†’ L'annonce passe en statut 'RÃ©servÃ©e':\n");
        annonce.changerStatut(StatutAnnonce.RESERVEE);
        
        // DÃ©tachement
        System.out.println("â†’ Diana se dÃ©sabonne des notifications SMS:\n");
        annonce.detach(smsObs);
        
        System.out.println("â†’ Nouvelle notification (sans SMS):\n");
        annonce.changerStatut(StatutAnnonce.ACTIVE);
        
        System.out.println("ğŸ“Š Le pattern Observer permet:");
        System.out.println("   - DÃ©couplage entre l'annonce et les modes de notification");
        System.out.println("   - Ajout facile de nouveaux canaux (Email, Push, SMS...)");
        System.out.println("   - Abonnement/dÃ©sabonnement dynamique\n");
    }
    
    /**
     * DÃ©monstration du Pattern STRATEGY.
     */
    private void demonstrationStrategy() {
        System.out.println("\n" +
                "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n" +
                "â”‚  ğŸ¯ PATTERN STRATEGY - Calcul flexible des prix                     â”‚\n" +
                "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");
        
        System.out.println("Le pattern Strategy permet de changer l'algorithme de");
        System.out.println("tarification sans modifier le code de la rÃ©servation.\n");
        
        Utilisateur alice = utilisateurs.get(0);
        Utilisateur bob = utilisateurs.get(1);
        Annonce velo = annonceService.getAnnonces().get(0);
        velo.changerStatut(StatutAnnonce.ACTIVE); // S'assurer que c'est disponible
        
        LocalDateTime debut = LocalDateTime.now().plusDays(1);
        LocalDateTime finCourt = debut.plusHours(3);    // 3 heures
        LocalDateTime finLong = debut.plusDays(10);     // 10 jours
        
        System.out.println("ğŸ“Œ Annonce: " + velo.getTitre());
        System.out.println("   Prix de base: " + velo.getPrixBase() + "â‚¬");
        System.out.println();
        
        System.out.println("â†’ Comparaison des stratÃ©gies pour une location de 3 heures:\n");
        
        // StratÃ©gie horaire
        StrategyTarification stratHoraire = new TarifHoraire();
        System.out.println("   " + stratHoraire.getNom() + ":");
        System.out.println("   " + stratHoraire.getDescription());
        System.out.println("   Prix: " + String.format("%.2fâ‚¬", 
                stratHoraire.calculerPrix(velo.getPrixBase(), 
                        java.time.Duration.between(debut, finCourt))));
        
        // StratÃ©gie journaliÃ¨re
        StrategyTarification stratJour = new TarifJournalier();
        System.out.println("\n   " + stratJour.getNom() + ":");
        System.out.println("   " + stratJour.getDescription());
        System.out.println("   Prix: " + String.format("%.2fâ‚¬", 
                stratJour.calculerPrix(velo.getPrixBase(), 
                        java.time.Duration.between(debut, finCourt))));
        
        // StratÃ©gie forfaitaire
        StrategyTarification stratForfait = new TarifForfaitaire();
        System.out.println("\n   " + stratForfait.getNom() + ":");
        System.out.println("   " + stratForfait.getDescription());
        System.out.println("   Prix: " + String.format("%.2fâ‚¬", 
                stratForfait.calculerPrix(velo.getPrixBase(), 
                        java.time.Duration.between(debut, finCourt))));
        
        // StratÃ©gie gratuite
        StrategyTarification stratGratuit = new TarifGratuit();
        System.out.println("\n   " + stratGratuit.getNom() + ":");
        System.out.println("   " + stratGratuit.getDescription());
        System.out.println("   Prix: " + String.format("%.2fâ‚¬", 
                stratGratuit.calculerPrix(velo.getPrixBase(), 
                        java.time.Duration.between(debut, finCourt))));
        
        System.out.println("\nâ†’ Comparaison pour une location longue durÃ©e (10 jours):\n");
        
        System.out.println("   Tarif Journalier (avec rÃ©duction -20% >= 7 jours):");
        System.out.println("   Prix: " + String.format("%.2fâ‚¬", 
                stratJour.calculerPrix(velo.getPrixBase(), 
                        java.time.Duration.between(debut, finLong))));
        System.out.println("   (au lieu de " + String.format("%.2fâ‚¬", velo.getPrixBase() * 10) + " sans rÃ©duction)");
        
        System.out.println("\nğŸ“Š Le pattern Strategy permet:");
        System.out.println("   - Changer la tarification Ã  la volÃ©e");
        System.out.println("   - Ajouter de nouvelles stratÃ©gies facilement");
        System.out.println("   - Code propre et maintenable\n");
    }
    
    /**
     * DÃ©monstration du Pattern ADAPTER.
     */
    private void demonstrationAdapter() {
        System.out.println("\n" +
                "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n" +
                "â”‚  ğŸ”Œ PATTERN ADAPTER - IntÃ©gration calendrier externe                â”‚\n" +
                "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");
        
        System.out.println("Le pattern Adapter permet d'intÃ©grer des systÃ¨mes externes");
        System.out.println("(comme Google Calendar) sans modifier notre code.\n");
        
        Utilisateur bob = utilisateurs.get(1);
        Utilisateur diana = utilisateurs.get(3);
        Annonce courseMaths = annonceService.getAnnonces().get(1);
        
        LocalDateTime debut = LocalDateTime.now().plusDays(2).withHour(14);
        LocalDateTime fin = debut.plusHours(2);
        
        System.out.println("â†’ CrÃ©ation d'une rÃ©servation avec tarif horaire:\n");
        
        Reservation reservation = reservationService.reserverAvecTarifHoraire(
                courseMaths, diana, debut, fin);
        
        System.out.println("\nâ†’ Confirmation de la rÃ©servation (sync avec Google Calendar):\n");
        reservationService.confirmerReservation(reservation);
        
        System.out.println("\nğŸ“Š Le pattern Adapter permet:");
        System.out.println("   - Notre code utilise l'interface 'Calendrier'");
        System.out.println("   - L'adaptateur traduit vers l'API Google");
        System.out.println("   - Facile de changer pour Outlook, Apple Calendar...\n");
    }
    
    /**
     * DÃ©monstration d'un scÃ©nario complet.
     */
    private void demonstrationScenarioComplet() {
        System.out.println("\n" +
                "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n" +
                "â”‚  ğŸ¬ SCÃ‰NARIO COMPLET - Tous les patterns en action                  â”‚\n" +
                "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");
        
        Utilisateur alice = utilisateurs.get(0);
        Utilisateur emma = utilisateurs.get(4);
        
        // Emma s'inscrit aux notifications
        System.out.println("1ï¸âƒ£  Emma s'abonne aux notifications de la catÃ©gorie 'Transport'\n");
        EmailObserver emmaEmail = new EmailObserver(emma);
        annonceService.ajouterObservateurGlobal(emmaEmail);
        
        // Alice publie une nouvelle annonce
        System.out.println("2ï¸âƒ£  Alice publie une nouvelle annonce de trottinette:\n");
        BienAnnonce trottinette = annonceService.publierBien(
                "Trottinette Ã©lectrique Xiaomi",
                "Trottinette Ã©lectrique, autonomie 25km, vitesse max 25km/h. " +
                "Parfaite pour aller en cours !",
                alice,
                categories.get(0), // Transport
                "TrÃ¨s bon Ã©tat",
                8.0 // 8â‚¬/jour
        );
        trottinette.setLocalisation("Parking RÃ©sidence A");
        
        // Emma fait une rÃ©servation
        System.out.println("\n3ï¸âƒ£  Emma rÃ©serve la trottinette pour 3 jours:\n");
        LocalDateTime debutRes = LocalDateTime.now().plusDays(1);
        LocalDateTime finRes = debutRes.plusDays(3);
        
        Reservation resaTrottinette = reservationService.reserverAvecTarifJournalier(
                trottinette, emma, debutRes, finRes);
        resaTrottinette.setMessageAccompagnement("Bonjour, j'ai besoin de la trottinette " +
                "pour aller au stage la semaine prochaine. Merci !");
        
        // Alice confirme
        System.out.println("\n4ï¸âƒ£  Alice confirme la rÃ©servation:\n");
        reservationService.confirmerReservation(resaTrottinette);
        
        // La rÃ©servation se termine
        System.out.println("\n5ï¸âƒ£  La rÃ©servation se termine:\n");
        reservationService.demarrerReservation(resaTrottinette);
        reservationService.terminerReservation(resaTrottinette);
        
        // Ã‰valuations mutuelles
        System.out.println("\n6ï¸âƒ£  Ã‰valuations mutuelles:\n");
        evaluationService.evaluerProprietaire(resaTrottinette, 5, 
                "Alice est trÃ¨s arrangeante, la trottinette Ã©tait impeccable !");
        evaluationService.evaluerDemandeur(resaTrottinette, 5, 
                "Emma a rendu la trottinette en parfait Ã©tat, je recommande !");
        
        System.out.println("\nâœ… ScÃ©nario terminÃ© avec succÃ¨s !");
        System.out.println("   Tous les patterns ont Ã©tÃ© utilisÃ©s:\n");
        System.out.println("   â€¢ Factory â†’ crÃ©ation de l'annonce trottinette");
        System.out.println("   â€¢ Observer â†’ notification Ã  Emma");
        System.out.println("   â€¢ Strategy â†’ calcul du prix (tarif journalier)");
        System.out.println("   â€¢ Adapter â†’ synchronisation calendrier");
    }
    
    /**
     * Affiche le rÃ©sumÃ© final.
     */
    private void afficherResume() {
        System.out.println("\n" +
                "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n" +
                "â•‘                         ğŸ“Š RÃ‰SUMÃ‰ FINAL                               â•‘\n" +
                "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
        
        System.out.println("ğŸ“Œ Statistiques de l'application:\n");
        System.out.println("   Utilisateurs: " + utilisateurs.size());
        System.out.println("   CatÃ©gories: " + categories.size());
        System.out.println("   Annonces publiÃ©es: " + annonceService.getNombreAnnonces());
        System.out.println("   Annonces actives: " + annonceService.getNombreAnnoncesActives());
        System.out.println("   RÃ©servations: " + reservationService.getNombreReservations());
        System.out.println("   Ã‰valuations: " + evaluationService.getNombreEvaluations());
        
        System.out.println("\nğŸ“Œ Design Patterns implÃ©mentÃ©s:\n");
        System.out.println("   âœ“ Simple Factory (AnnonceFactory)");
        System.out.println("   âœ“ Observer (systÃ¨me de notifications)");
        System.out.println("   âœ“ Strategy (tarification flexible)");
        System.out.println("   âœ“ Adapter (intÃ©gration calendrier)");
        
        System.out.println("\nğŸ“Œ FonctionnalitÃ©s principales:\n");
        System.out.println("   âœ“ Publication d'annonces (Biens, Services, Dons)");
        System.out.println("   âœ“ Recherche et filtrage");
        System.out.println("   âœ“ SystÃ¨me de rÃ©servation");
        System.out.println("   âœ“ Calcul de prix flexible");
        System.out.println("   âœ“ Notifications multi-canaux");
        System.out.println("   âœ“ Ã‰valuations et rÃ©putation");
        System.out.println("   âœ“ IntÃ©gration calendrier externe");
        
        System.out.println("\n" +
                "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" +
                "                    FIN DE LA DÃ‰MONSTRATION                                \n" +
                "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    }
    
    // ==================== Initialisation des donnÃ©es ====================
    
    /**
     * Initialise les catÃ©gories prÃ©dÃ©finies.
     */
    private void initialiserCategories() {
        categories = Arrays.asList(
                new Categorie("CAT001", "Transport", "VÃ©los, trottinettes, covoiturage", "ğŸš²"),
                new Categorie("CAT002", "High-Tech", "Ordinateurs, tÃ©lÃ©phones, accessoires", "ğŸ’»"),
                new Categorie("CAT003", "Logement", "Meubles, Ã©lectromÃ©nager, dÃ©co", "ğŸ "),
                new Categorie("CAT004", "Ã‰tudes", "Livres, cours, tutorat", "ğŸ“š"),
                new Categorie("CAT005", "Loisirs", "Sport, musique, jeux", "ğŸ®"),
                new Categorie("CAT006", "Entraide", "Aide diverse, services", "ğŸ¤")
        );
    }
    
    /**
     * Initialise les utilisateurs de dÃ©monstration.
     */
    private void initialiserUtilisateurs() {
        utilisateurs = Arrays.asList(
                new Utilisateur("U001", "Martin", "Alice", "alice.martin@etu.univ.fr", "pass123"),
                new Utilisateur("U002", "Dupont", "Bob", "bob.dupont@etu.univ.fr", "pass123"),
                new Utilisateur("U003", "Durand", "Charlie", "charlie.durand@etu.univ.fr", "pass123"),
                new Utilisateur("U004", "Leroy", "Diana", "diana.leroy@etu.univ.fr", "pass123"),
                new Utilisateur("U005", "Bernard", "Emma", "emma.bernard@etu.univ.fr", "pass123")
        );
    }
    
    // ==================== Getters pour les tests ====================
    
    public AnnonceService getAnnonceService() {
        return annonceService;
    }
    
    public ReservationService getReservationService() {
        return reservationService;
    }
    
    public EvaluationService getEvaluationService() {
        return evaluationService;
    }
    
    public List<Categorie> getCategories() {
        return categories;
    }
    
    public List<Utilisateur> getUtilisateurs() {
        return utilisateurs;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/model/StatutAnnonce.java
package com.campusshare.model;

/**
 * Ã‰numÃ©ration des diffÃ©rents statuts possibles pour une annonce.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public enum StatutAnnonce {

    ACTIVE("Active", "ğŸŸ¢"),
    RESERVEE("RÃ©servÃ©e", "ğŸŸ¡"),
    INDISPONIBLE("Indisponible", "ğŸ”´"),
    EXPIREE("ExpirÃ©e", "â°"),
    TERMINEE("TerminÃ©e", "âš«"),
    SUPPRIMEE("SupprimÃ©e", "ğŸ—‘ï¸");
    
    private final String libelle;
    private final String icone;
    
    StatutAnnonce(String libelle, String icone) {
        this.libelle = libelle;
        this.icone = icone;
    }
    
    public String getLibelle() {
        return libelle;
    }
    
    public String getIcone() {
        return icone;
    }
    
    @Override
    public String toString() {
        return icone + " " + libelle;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/model/Evaluation.java
package com.campusshare.model;

import java.time.LocalDateTime;

/**
 * Classe reprÃ©sentant une Ã©valuation laissÃ©e aprÃ¨s une transaction.
 * Les Ã©valuations permettent de construire la rÃ©putation des utilisateurs.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class Evaluation {
    
    private String id;
    private Utilisateur evaluateur;      // Celui qui Ã©value
    private Utilisateur evaluer;         // Celui qui est Ã©valuÃ©
    private int note;                    // Note de 1 Ã  5
    private String commentaire;
    private LocalDateTime dateEvaluation;
    private String reservationId;        // RÃ©fÃ©rence Ã  la rÃ©servation concernÃ©e
    
    /**
     * Constructeur de l'Ã©valuation.
     * 
     * @param id Identifiant unique
     * @param evaluateur L'utilisateur qui Ã©value
     * @param evaluer L'utilisateur Ã©valuÃ©
     * @param note Note de 1 Ã  5
     * @param commentaire Commentaire optionnel
     * @param reservationId ID de la rÃ©servation associÃ©e
     */
    public Evaluation(String id, Utilisateur evaluateur, Utilisateur evaluer, 
                      int note, String commentaire, String reservationId) {
        if (note < 1 || note > 5) {
            throw new IllegalArgumentException("La note doit Ãªtre entre 1 et 5");
        }
        this.id = id;
        this.evaluateur = evaluateur;
        this.evaluer = evaluer;
        this.note = note;
        this.commentaire = commentaire;
        this.reservationId = reservationId;
        this.dateEvaluation = LocalDateTime.now();
    }
    
    /**
     * Retourne une reprÃ©sentation textuelle de la note avec des Ã©toiles.
     * 
     * @return ChaÃ®ne d'Ã©toiles
     */
    public String getNoteEnEtoiles() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 5; i++) {
            sb.append(i < note ? "â˜…" : "â˜†");
        }
        return sb.toString();
    }
    
    // Getters et Setters
    
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public Utilisateur getEvaluateur() {
        return evaluateur;
    }
    
    public void setEvaluateur(Utilisateur evaluateur) {
        this.evaluateur = evaluateur;
    }
    
    public Utilisateur getEvaluer() {
        return evaluer;
    }
    
    public void setEvaluer(Utilisateur evaluer) {
        this.evaluer = evaluer;
    }
    
    public int getNote() {
        return note;
    }
    
    public void setNote(int note) {
        if (note < 1 || note > 5) {
            throw new IllegalArgumentException("La note doit Ãªtre entre 1 et 5");
        }
        this.note = note;
    }
    
    public String getCommentaire() {
        return commentaire;
    }
    
    public void setCommentaire(String commentaire) {
        this.commentaire = commentaire;
    }
    
    public LocalDateTime getDateEvaluation() {
        return dateEvaluation;
    }
    
    public String getReservationId() {
        return reservationId;
    }
    
    @Override
    public String toString() {
        return String.format("%s - %s\n\"%s\" - par %s", 
                getNoteEnEtoiles(), 
                dateEvaluation.toLocalDate(),
                commentaire,
                evaluateur.getNomComplet());
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/model/Categorie.java
package com.campusshare.model;

/**
 * Classe reprÃ©sentant une catÃ©gorie d'annonces.
 * Les catÃ©gories permettent de classer et filtrer les annonces.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class Categorie {
    
    private String id;
    private String nom;
    private String description;
    private String icone; // Emoji ou nom d'icÃ´ne
    
    /**
     * Constructeur de la catÃ©gorie.
     * 
     * @param id Identifiant unique
     * @param nom Nom de la catÃ©gorie
     * @param description Description de la catÃ©gorie
     * @param icone IcÃ´ne reprÃ©sentative
     */
    public Categorie(String id, String nom, String description, String icone) {
        this.id = id;
        this.nom = nom;
        this.description = description;
        this.icone = icone;
    }
    
    /**
     * Constructeur simplifiÃ©.
     * 
     * @param id Identifiant unique
     * @param nom Nom de la catÃ©gorie
     */
    public Categorie(String id, String nom) {
        this(id, nom, "", "ğŸ“¦");
    }
    
    // Getters et Setters
    
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getNom() {
        return nom;
    }
    
    public void setNom(String nom) {
        this.nom = nom;
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public String getIcone() {
        return icone;
    }
    
    public void setIcone(String icone) {
        this.icone = icone;
    }
    
    @Override
    public String toString() {
        return icone + " " + nom;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Categorie categorie = (Categorie) obj;
        return id.equals(categorie.id);
    }
    
    @Override
    public int hashCode() {
        return id.hashCode();
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/model/Reservation.java
package com.campusshare.model;

import com.campusshare.model.annonce.Annonce;
import com.campusshare.strategy.StrategyTarification;
import java.time.LocalDateTime;
import java.time.Duration;

/**
 * Classe reprÃ©sentant une rÃ©servation d'un bien ou service.
 * Utilise le pattern Strategy pour le calcul du prix.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class Reservation {
    
    private String id;
    private Annonce annonce;
    private Utilisateur demandeur;       // Celui qui fait la demande
    private Utilisateur proprietaire;    // PropriÃ©taire de l'annonce
    private LocalDateTime dateDebut;
    private LocalDateTime dateFin;
    private LocalDateTime dateCreation;
    private StatutReservation statut;
    private double prixTotal;
    private String messageAccompagnement;
    private StrategyTarification strategyTarification; // Pattern Strategy
    
    /**
     * Constructeur de la rÃ©servation.
     * 
     * @param id Identifiant unique
     * @param annonce L'annonce concernÃ©e
     * @param demandeur L'utilisateur qui demande
     * @param dateDebut Date de dÃ©but de la rÃ©servation
     * @param dateFin Date de fin de la rÃ©servation
     * @param strategyTarification StratÃ©gie de calcul du prix
     */
    public Reservation(String id, Annonce annonce, Utilisateur demandeur,
                       LocalDateTime dateDebut, LocalDateTime dateFin,
                       StrategyTarification strategyTarification) {
        this.id = id;
        this.annonce = annonce;
        this.demandeur = demandeur;
        this.proprietaire = annonce.getProprietaire();
        this.dateDebut = dateDebut;
        this.dateFin = dateFin;
        this.dateCreation = LocalDateTime.now();
        this.statut = StatutReservation.EN_ATTENTE;
        this.strategyTarification = strategyTarification;
        this.prixTotal = calculerPrix();
    }
    
    /**
     * Calcule le prix total de la rÃ©servation en utilisant la stratÃ©gie de tarification.
     * Pattern Strategy en action.
     * 
     * @return Le prix calculÃ©
     */
    public double calculerPrix() {
        if (strategyTarification == null) {
            return 0.0;
        }
        Duration duree = Duration.between(dateDebut, dateFin);
        return strategyTarification.calculerPrix(annonce.getPrixBase(), duree);
    }
    
    /**
     * Confirme la rÃ©servation.
     */
    public void confirmer() {
        if (statut == StatutReservation.EN_ATTENTE) {
            statut = StatutReservation.CONFIRMEE;
        }
    }
    
    /**
     * DÃ©marre la rÃ©servation (le bien est remis ou le service commence).
     */
    public void demarrer() {
        if (statut == StatutReservation.CONFIRMEE) {
            statut = StatutReservation.EN_COURS;
        }
    }
    
    /**
     * Termine la rÃ©servation.
     */
    public void terminer() {
        if (statut == StatutReservation.EN_COURS || statut == StatutReservation.CONFIRMEE) {
            statut = StatutReservation.TERMINEE;
        }
    }
    
    /**
     * Annule la rÃ©servation.
     */
    public void annuler() {
        if (statut == StatutReservation.EN_ATTENTE || statut == StatutReservation.CONFIRMEE) {
            statut = StatutReservation.ANNULEE;
        }
    }
    
    /**
     * Refuse la rÃ©servation.
     */
    public void refuser() {
        if (statut == StatutReservation.EN_ATTENTE) {
            statut = StatutReservation.REFUSEE;
        }
    }
    
    /**
     * Calcule la durÃ©e de la rÃ©servation en heures.
     * 
     * @return DurÃ©e en heures
     */
    public long getDureeEnHeures() {
        return Duration.between(dateDebut, dateFin).toHours();
    }
    
    /**
     * VÃ©rifie si la rÃ©servation peut Ãªtre Ã©valuÃ©e.
     * 
     * @return true si la rÃ©servation est terminÃ©e
     */
    public boolean peutEtreEvaluee() {
        return statut == StatutReservation.TERMINEE;
    }
    
    // Getters et Setters
    
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public Annonce getAnnonce() {
        return annonce;
    }
    
    public void setAnnonce(Annonce annonce) {
        this.annonce = annonce;
    }
    
    public Utilisateur getDemandeur() {
        return demandeur;
    }
    
    public void setDemandeur(Utilisateur demandeur) {
        this.demandeur = demandeur;
    }
    
    public Utilisateur getProprietaire() {
        return proprietaire;
    }
    
    public LocalDateTime getDateDebut() {
        return dateDebut;
    }
    
    public void setDateDebut(LocalDateTime dateDebut) {
        this.dateDebut = dateDebut;
        this.prixTotal = calculerPrix();
    }
    
    public LocalDateTime getDateFin() {
        return dateFin;
    }
    
    public void setDateFin(LocalDateTime dateFin) {
        this.dateFin = dateFin;
        this.prixTotal = calculerPrix();
    }
    
    public LocalDateTime getDateCreation() {
        return dateCreation;
    }
    
    public StatutReservation getStatut() {
        return statut;
    }
    
    public double getPrixTotal() {
        return prixTotal;
    }
    
    public String getMessageAccompagnement() {
        return messageAccompagnement;
    }
    
    public void setMessageAccompagnement(String messageAccompagnement) {
        this.messageAccompagnement = messageAccompagnement;
    }
    
    public StrategyTarification getStrategyTarification() {
        return strategyTarification;
    }
    
    /**
     * Change la stratÃ©gie de tarification et recalcule le prix.
     * 
     * @param strategyTarification Nouvelle stratÃ©gie
     */
    public void setStrategyTarification(StrategyTarification strategyTarification) {
        this.strategyTarification = strategyTarification;
        this.prixTotal = calculerPrix();
    }
    
    @Override
    public String toString() {
        return String.format("RÃ©servation[%s] %s\n  %s â†’ %s\n  Demandeur: %s\n  Prix: %.2fâ‚¬\n  Statut: %s",
                id,
                annonce.getTitre(),
                dateDebut.toLocalDate(),
                dateFin.toLocalDate(),
                demandeur.getNomComplet(),
                prixTotal,
                statut);
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/model/StatutTransaction.java
package com.campusshare.model;

/**
 * Ã‰numÃ©ration reprÃ©sentant les diffÃ©rents statuts d'une transaction.
 *
 * @author Equipe CampusShare - Member 3
 * @version 1.0
 */
public enum StatutTransaction {
    /**
     * Transaction en attente de traitement
     */
    EN_ATTENTE("En attente"),

    /**
     * Transaction validÃ©e et complÃ©tÃ©e
     */
    VALIDE("ValidÃ©e"),

    /**
     * Transaction refusÃ©e
     */
    REFUSE("RefusÃ©e"),

    /**
     * Transaction annulÃ©e
     */
    ANNULE("AnnulÃ©e");

    private final String libelle;

    StatutTransaction(String libelle) {
        this.libelle = libelle;
    }

    public String getLibelle() {
        return libelle;
    }

    @Override
    public String toString() {
        return libelle;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/model/Etudiant.java
package com.campusshare.model;

import com.campusshare.model.annonce.Annonce;

/**
 * Classe reprÃ©sentant un Ã©tudiant de l'application CampusShare.
 * Un Ã©tudiant hÃ©rite d'Utilisateur et possÃ¨de des points campus
 * utilisables pour les transactions.
 *
 * @author Equipe CampusShare - Member 3
 * @version 1.0
 */
public class Etudiant extends Utilisateur {

    private String numEtudiant;
    private int soldePoints;
    private String campus;

    /**
     * Constructeur de l'Ã©tudiant.
     *
     * @param id Identifiant unique
     * @param nom Nom de famille
     * @param prenom PrÃ©nom
     * @param email Email universitaire
     * @param motDePasse Mot de passe hashÃ©
     * @param numEtudiant NumÃ©ro Ã©tudiant
     * @param campus Nom du campus
     */
    public Etudiant(String id, String nom, String prenom, String email,
                    String motDePasse, String numEtudiant, String campus) {
        super(id, nom, prenom, email, motDePasse);
        this.numEtudiant = numEtudiant;
        this.campus = campus;
        this.soldePoints = 100; // Solde initial
    }

    /**
     * CrÃ©dite des points au compte de l'Ã©tudiant.
     *
     * @param montant Le montant de points Ã  crÃ©diter
     */
    public void crediterPoints(int montant) {
        if (montant > 0) {
            this.soldePoints += montant;
            System.out.println("[CREDIT] +" + montant + " points -> Nouveau solde: " + this.soldePoints + " points");
        }
    }

    /**
     * DÃ©bite des points du compte de l'Ã©tudiant.
     *
     * @param montant Le montant de points Ã  dÃ©biter
     * @return true si le dÃ©bit a rÃ©ussi, false si solde insuffisant
     */
    public boolean debiterPoints(int montant) {
        if (montant <= 0) {
            return false;
        }

        if (this.soldePoints >= montant) {
            this.soldePoints -= montant;
            System.out.println("[DEBIT] -" + montant + " points -> Nouveau solde: " + this.soldePoints + " points");
            return true;
        } else {
            System.out.println("[ECHEC] Solde insuffisant: " + this.soldePoints + " points (requis: " + montant + ")");
            return false;
        }
    }

    /**
     * Demande d'Ã©change pour une annonce.
     *
     * @param annonce L'annonce concernÃ©e
     */
    public void demanderEchange(Annonce annonce) {
        System.out.println(getNomComplet() + " demande un Ã©change pour: " + annonce.getTitre());
    }

    /**
     * Calcule la rÃ©putation de l'Ã©tudiant.
     *
     * @return La rÃ©putation (note moyenne)
     */
    public double calculerReputation() {
        return getReputation();
    }

    // Getters et Setters

    public String getNumEtudiant() {
        return numEtudiant;
    }

    public void setNumEtudiant(String numEtudiant) {
        this.numEtudiant = numEtudiant;
    }

    public int getSoldePoints() {
        return soldePoints;
    }

    public void setSoldePoints(int soldePoints) {
        this.soldePoints = soldePoints;
    }

    public String getCampus() {
        return campus;
    }

    public void setCampus(String campus) {
        this.campus = campus;
    }

    @Override
    public String toString() {
        return String.format("Etudiant[%s] %s - Campus: %s - Points: %d - Rep: %.1fâ˜…",
                numEtudiant, getNomComplet(), campus, soldePoints, getReputation());
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/model/annonce/BienAnnonce.java
package com.campusshare.model.annonce;

import com.campusshare.model.Categorie;
import com.campusshare.model.Utilisateur;

/**
 * Classe reprÃ©sentant une annonce de bien Ã  prÃªter ou louer.
 * Exemples: livres, vÃ©los, matÃ©riel Ã©lectronique, meubles, etc.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class BienAnnonce extends Annonce {
    
    private String etat; // Neuf, TrÃ¨s bon Ã©tat, Bon Ã©tat, UsÃ©
    private String marque;
    private String modele;
    private boolean cautionRequise;
    private double montantCaution;
    private int dureeMaxPretJours; // DurÃ©e maximale de prÃªt en jours
    
    /**
     * Constructeur de BienAnnonce.
     * 
     * @param id Identifiant unique
     * @param titre Titre de l'annonce
     * @param description Description dÃ©taillÃ©e
     * @param proprietaire Utilisateur propriÃ©taire
     * @param categorie CatÃ©gorie de l'annonce
     */
    public BienAnnonce(String id, String titre, String description,
                       Utilisateur proprietaire, Categorie categorie) {
        super(id, titre, description, proprietaire, categorie);
        this.etat = "Bon Ã©tat";
        this.cautionRequise = false;
        this.montantCaution = 0.0;
        this.dureeMaxPretJours = 7; // Par dÃ©faut 1 semaine
    }
    
    @Override
    public TypeAnnonce getType() {
        return TypeAnnonce.BIEN;
    }
    
    @Override
    public String getDetailsSpecifiques() {
        StringBuilder sb = new StringBuilder();
        sb.append("=== DÃ©tails du bien ===\n");
        sb.append("Ã‰tat: ").append(etat).append("\n");
        if (marque != null && !marque.isEmpty()) {
            sb.append("Marque: ").append(marque).append("\n");
        }
        if (modele != null && !modele.isEmpty()) {
            sb.append("ModÃ¨le: ").append(modele).append("\n");
        }
        sb.append("DurÃ©e max de prÃªt: ").append(dureeMaxPretJours).append(" jours\n");
        if (cautionRequise) {
            sb.append("âš ï¸ Caution requise: ").append(String.format("%.2fâ‚¬", montantCaution)).append("\n");
        }
        return sb.toString();
    }
    
    // Getters et Setters spÃ©cifiques
    
    public String getEtat() {
        return etat;
    }
    
    public void setEtat(String etat) {
        this.etat = etat;
    }
    
    public String getMarque() {
        return marque;
    }
    
    public void setMarque(String marque) {
        this.marque = marque;
    }
    
    public String getModele() {
        return modele;
    }
    
    public void setModele(String modele) {
        this.modele = modele;
    }
    
    public boolean isCautionRequise() {
        return cautionRequise;
    }
    
    public void setCautionRequise(boolean cautionRequise) {
        this.cautionRequise = cautionRequise;
    }
    
    public double getMontantCaution() {
        return montantCaution;
    }
    
    public void setMontantCaution(double montantCaution) {
        this.montantCaution = montantCaution;
        if (montantCaution > 0) {
            this.cautionRequise = true;
        }
    }
    
    public int getDureeMaxPretJours() {
        return dureeMaxPretJours;
    }
    
    public void setDureeMaxPretJours(int dureeMaxPretJours) {
        this.dureeMaxPretJours = dureeMaxPretJours;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/model/annonce/DonAnnonce.java
package com.campusshare.model.annonce;

import com.campusshare.model.Categorie;
import com.campusshare.model.Utilisateur;

/**
 * Classe reprÃ©sentant une annonce de don gratuit.
 * Le don est un partage solidaire entre Ã©tudiants.
 * Exemples: vÃªtements, livres, nourriture non pÃ©rissable, petit mobilier, etc.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class DonAnnonce extends Annonce {
    
    private String etatObjet; // Neuf, TrÃ¨s bon Ã©tat, Bon Ã©tat, Ã€ rÃ©nover
    private String raisonDon; // DÃ©mÃ©nagement, Fin d'Ã©tudes, Surplus, etc.
    private boolean retraitSurPlace; // L'objet doit Ãªtre rÃ©cupÃ©rÃ© sur place
    private String conditionsRecuperation; // Conditions particuliÃ¨res
    private int quantiteDisponible; // Nombre d'objets disponibles
    
    /**
     * Constructeur de DonAnnonce.
     * 
     * @param id Identifiant unique
     * @param titre Titre de l'annonce
     * @param description Description dÃ©taillÃ©e
     * @param proprietaire Utilisateur propriÃ©taire
     * @param categorie CatÃ©gorie de l'annonce
     */
    public DonAnnonce(String id, String titre, String description,
                      Utilisateur proprietaire, Categorie categorie) {
        super(id, titre, description, proprietaire, categorie);
        this.prixBase = 0.0; // Un don est toujours gratuit
        this.etatObjet = "Bon Ã©tat";
        this.retraitSurPlace = true;
        this.quantiteDisponible = 1;
    }
    
    @Override
    public TypeAnnonce getType() {
        return TypeAnnonce.DON;
    }
    
    @Override
    public String getDetailsSpecifiques() {
        StringBuilder sb = new StringBuilder();
        sb.append("=== DÃ©tails du don ===\n");
        sb.append("ğŸ DON GRATUIT\n");
        sb.append("Ã‰tat: ").append(etatObjet).append("\n");
        sb.append("QuantitÃ© disponible: ").append(quantiteDisponible).append("\n");
        
        if (raisonDon != null && !raisonDon.isEmpty()) {
            sb.append("Raison du don: ").append(raisonDon).append("\n");
        }
        
        sb.append("Retrait sur place: ").append(retraitSurPlace ? "Oui" : "Non").append("\n");
        
        if (conditionsRecuperation != null && !conditionsRecuperation.isEmpty()) {
            sb.append("Conditions: ").append(conditionsRecuperation).append("\n");
        }
        
        return sb.toString();
    }
    
    /**
     * Pour un don, le prix est toujours 0.
     * Cette mÃ©thode est surchargÃ©e pour garantir la gratuitÃ©.
     */
    @Override
    public void setPrixBase(double prixBase) {
        // Un don est toujours gratuit
        super.setPrixBase(0.0);
    }
    
    /**
     * DÃ©crÃ©mente la quantitÃ© disponible lors d'une rÃ©cupÃ©ration.
     * 
     * @return true si un objet a Ã©tÃ© rÃ©servÃ©, false si plus rien n'est disponible
     */
    public boolean reserverUnite() {
        if (quantiteDisponible > 0) {
            quantiteDisponible--;
            if (quantiteDisponible == 0) {
                notifyObservers("Le don '" + getTitre() + "' n'est plus disponible.");
            }
            return true;
        }
        return false;
    }
    
    // Getters et Setters spÃ©cifiques
    
    public String getEtatObjet() {
        return etatObjet;
    }
    
    public void setEtatObjet(String etatObjet) {
        this.etatObjet = etatObjet;
    }
    
    public String getRaisonDon() {
        return raisonDon;
    }
    
    public void setRaisonDon(String raisonDon) {
        this.raisonDon = raisonDon;
    }
    
    public boolean isRetraitSurPlace() {
        return retraitSurPlace;
    }
    
    public void setRetraitSurPlace(boolean retraitSurPlace) {
        this.retraitSurPlace = retraitSurPlace;
    }
    
    public String getConditionsRecuperation() {
        return conditionsRecuperation;
    }
    
    public void setConditionsRecuperation(String conditionsRecuperation) {
        this.conditionsRecuperation = conditionsRecuperation;
    }
    
    public int getQuantiteDisponible() {
        return quantiteDisponible;
    }
    
    public void setQuantiteDisponible(int quantiteDisponible) {
        this.quantiteDisponible = quantiteDisponible;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/model/annonce/TypeAnnonce.java
package com.campusshare.model.annonce;

/**
 * Ã‰numÃ©ration des types d'annonces disponibles dans l'application.
 * UtilisÃ©e par la Simple Factory pour crÃ©er le bon type d'annonce.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public enum TypeAnnonce {
    
    BIEN("Bien Ã  prÃªter/louer", "ğŸ“¦"),
    SERVICE("Service Ã  proposer", "ğŸ› ï¸"),
    DON("Don", "ğŸ");
    
    private final String libelle;
    private final String icone;
    
    TypeAnnonce(String libelle, String icone) {
        this.libelle = libelle;
        this.icone = icone;
    }
    
    public String getLibelle() {
        return libelle;
    }
    
    public String getIcone() {
        return icone;
    }
    
    @Override
    public String toString() {
        return icone + " " + libelle;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/model/annonce/Annonce.java
package com.campusshare.model.annonce;

import com.campusshare.model.Categorie;
import com.campusshare.model.StatutAnnonce;
import com.campusshare.model.Utilisateur;
import com.campusshare.observer.Observable;
import com.campusshare.observer.Observer;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Classe abstraite reprÃ©sentant une annonce dans l'application.
 * ImplÃ©mente le pattern Observer en tant que Subject (Observable).
 * 
 * Les sous-classes concrÃ¨tes sont crÃ©Ã©es via le pattern Simple Factory.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public abstract class Annonce implements Observable {
    
    protected String id;
    protected String titre;
    protected String description;
    protected Utilisateur proprietaire;
    protected Categorie categorie;
    protected double prixBase;
    protected StatutAnnonce statut;
    protected LocalDateTime dateCreation;
    protected LocalDateTime dateModification;
    protected String localisation; // Ex: "BÃ¢timent A, Campus Nord"
    protected List<String> images; // URLs des images
    protected int nombreVues;
    
    // Pattern Observer - liste des observateurs intÃ©ressÃ©s par cette annonce
    private List<Observer> observers;
    
    /**
     * Constructeur de l'annonce.
     * 
     * @param id Identifiant unique
     * @param titre Titre de l'annonce
     * @param description Description dÃ©taillÃ©e
     * @param proprietaire Utilisateur propriÃ©taire
     * @param categorie CatÃ©gorie de l'annonce
     */
    public Annonce(String id, String titre, String description, 
                   Utilisateur proprietaire, Categorie categorie) {
        this.id = id;
        this.titre = titre;
        this.description = description;
        this.proprietaire = proprietaire;
        this.categorie = categorie;
        this.prixBase = 0.0;
        this.statut = StatutAnnonce.ACTIVE;
        this.dateCreation = LocalDateTime.now();
        this.dateModification = LocalDateTime.now();
        this.localisation = "";
        this.images = new ArrayList<>();
        this.nombreVues = 0;
        this.observers = new ArrayList<>();
    }
    
    // ==================== Pattern Observer - ImplÃ©mentation ====================
    
    /**
     * Attache un observateur Ã  cette annonce.
     * 
     * @param observer L'observateur Ã  ajouter
     */
    @Override
    public void attach(Observer observer) {
        if (!observers.contains(observer)) {
            observers.add(observer);
        }
    }
    
    /**
     * DÃ©tache un observateur de cette annonce.
     * 
     * @param observer L'observateur Ã  retirer
     */
    @Override
    public void detach(Observer observer) {
        observers.remove(observer);
    }
    
    /**
     * Notifie tous les observateurs d'un changement.
     * 
     * @param message Le message de notification
     */
    @Override
    public void notifyObservers(String message) {
        for (Observer observer : observers) {
            observer.update(this, message);
        }
    }
    
    // ==================== MÃ©thodes mÃ©tier ====================
    
    /**
     * MÃ©thode abstraite pour obtenir le type d'annonce.
     * Chaque sous-classe retourne son type.
     * 
     * @return Le type d'annonce
     */
    public abstract TypeAnnonce getType();
    
    /**
     * MÃ©thode abstraite pour afficher les dÃ©tails spÃ©cifiques.
     * 
     * @return ChaÃ®ne avec les dÃ©tails spÃ©cifiques au type
     */
    public abstract String getDetailsSpecifiques();
    
    /**
     * IncrÃ©mente le compteur de vues.
     */
    public void incrementerVues() {
        this.nombreVues++;
    }
    
    /**
     * Met Ã  jour le statut et notifie les observateurs.
     * 
     * @param nouveauStatut Le nouveau statut
     */
    public void changerStatut(StatutAnnonce nouveauStatut) {
        StatutAnnonce ancienStatut = this.statut;
        this.statut = nouveauStatut;
        this.dateModification = LocalDateTime.now();
        
        // Notification aux observateurs
        notifyObservers(String.format("L'annonce '%s' est passÃ©e de %s Ã  %s", 
                titre, ancienStatut, nouveauStatut));
    }
    
    /**
     * VÃ©rifie si l'annonce est disponible pour une rÃ©servation.
     *
     * @return true si l'annonce est active
     */
    public boolean estDisponible() {
        return statut == StatutAnnonce.ACTIVE;
    }

    /**
     * Modifie la disponibilitÃ© de l'annonce.
     *
     * @param disponible true pour rendre disponible, false sinon
     */
    public void setEstDisponible(boolean disponible) {
        if (disponible && statut != StatutAnnonce.ACTIVE) {
            changerStatut(StatutAnnonce.ACTIVE);
        } else if (!disponible && statut == StatutAnnonce.ACTIVE) {
            changerStatut(StatutAnnonce.EXPIREE);
        }
    }

    /**
     * Retourne le prix estimÃ© de l'annonce (alias pour prixBase).
     *
     * @return Le prix estimÃ©
     */
    public double getPrixEstime() {
        return prixBase;
    }

    /**
     * Retourne l'auteur de l'annonce (alias pour proprietaire).
     *
     * @return L'utilisateur propriÃ©taire
     */
    public Utilisateur getAuteur() {
        return proprietaire;
    }
    
    /**
     * Ajoute une image Ã  l'annonce.
     * 
     * @param urlImage URL de l'image
     */
    public void ajouterImage(String urlImage) {
        images.add(urlImage);
        this.dateModification = LocalDateTime.now();
    }
    
    // ==================== Getters et Setters ====================
    
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getTitre() {
        return titre;
    }
    
    public void setTitre(String titre) {
        this.titre = titre;
        this.dateModification = LocalDateTime.now();
        notifyObservers("Le titre de l'annonce a Ã©tÃ© modifiÃ©: " + titre);
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
        this.dateModification = LocalDateTime.now();
    }
    
    public Utilisateur getProprietaire() {
        return proprietaire;
    }
    
    public void setProprietaire(Utilisateur proprietaire) {
        this.proprietaire = proprietaire;
    }
    
    public Categorie getCategorie() {
        return categorie;
    }
    
    public void setCategorie(Categorie categorie) {
        this.categorie = categorie;
        this.dateModification = LocalDateTime.now();
    }
    
    public double getPrixBase() {
        return prixBase;
    }
    
    public void setPrixBase(double prixBase) {
        this.prixBase = prixBase;
        this.dateModification = LocalDateTime.now();
        notifyObservers(String.format("Le prix de '%s' a Ã©tÃ© modifiÃ©: %.2fâ‚¬", titre, prixBase));
    }
    
    public StatutAnnonce getStatut() {
        return statut;
    }
    
    public LocalDateTime getDateCreation() {
        return dateCreation;
    }
    
    public LocalDateTime getDateModification() {
        return dateModification;
    }
    
    public String getLocalisation() {
        return localisation;
    }
    
    public void setLocalisation(String localisation) {
        this.localisation = localisation;
        this.dateModification = LocalDateTime.now();
    }
    
    public List<String> getImages() {
        return images;
    }
    
    public int getNombreVues() {
        return nombreVues;
    }
    
    public List<Observer> getObservers() {
        return observers;
    }
    
    @Override
    public String toString() {
        return String.format("%s %s [%s]\n  %s\n  Prix: %.2fâ‚¬ | %s | Vues: %d\n  Par: %s",
                getType().getIcone(),
                titre,
                statut,
                description.length() > 50 ? description.substring(0, 50) + "..." : description,
                prixBase,
                categorie,
                nombreVues,
                proprietaire.getNomComplet());
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/model/annonce/ServiceAnnonce.java
package com.campusshare.model.annonce;

import com.campusshare.model.Categorie;
import com.campusshare.model.Utilisateur;

import java.time.DayOfWeek;
import java.util.ArrayList;
import java.util.List;

/**
 * Classe reprÃ©sentant une annonce de service Ã  proposer.
 * Exemples: cours particuliers, covoiturage, aide au dÃ©mÃ©nagement, 
 * relecture de mÃ©moire, baby-sitting, etc.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class ServiceAnnonce extends Annonce {
    
    private String typeService; // Tutorat, Covoiturage, Aide, etc.
    private int dureeMinutesEstimee; // DurÃ©e estimÃ©e de la prestation
    private List<DayOfWeek> joursDisponibles;
    private String horaireDisponible; // Ex: "14h-18h"
    private boolean deplacementPossible;
    private String niveauExpertise; // DÃ©butant, IntermÃ©diaire, Expert
    private List<String> competences; // Liste des compÃ©tences pour ce service
    
    /**
     * Constructeur de ServiceAnnonce.
     * 
     * @param id Identifiant unique
     * @param titre Titre de l'annonce
     * @param description Description dÃ©taillÃ©e
     * @param proprietaire Utilisateur propriÃ©taire
     * @param categorie CatÃ©gorie de l'annonce
     */
    public ServiceAnnonce(String id, String titre, String description,
                          Utilisateur proprietaire, Categorie categorie) {
        super(id, titre, description, proprietaire, categorie);
        this.joursDisponibles = new ArrayList<>();
        this.competences = new ArrayList<>();
        this.dureeMinutesEstimee = 60; // 1 heure par dÃ©faut
        this.deplacementPossible = true;
        this.niveauExpertise = "IntermÃ©diaire";
    }
    
    @Override
    public TypeAnnonce getType() {
        return TypeAnnonce.SERVICE;
    }
    
    @Override
    public String getDetailsSpecifiques() {
        StringBuilder sb = new StringBuilder();
        sb.append("=== DÃ©tails du service ===\n");
        if (typeService != null && !typeService.isEmpty()) {
            sb.append("Type: ").append(typeService).append("\n");
        }
        sb.append("DurÃ©e estimÃ©e: ").append(dureeMinutesEstimee).append(" minutes\n");
        sb.append("Niveau d'expertise: ").append(niveauExpertise).append("\n");
        
        if (!joursDisponibles.isEmpty()) {
            sb.append("Jours disponibles: ");
            for (int i = 0; i < joursDisponibles.size(); i++) {
                sb.append(traduireJour(joursDisponibles.get(i)));
                if (i < joursDisponibles.size() - 1) sb.append(", ");
            }
            sb.append("\n");
        }
        
        if (horaireDisponible != null && !horaireDisponible.isEmpty()) {
            sb.append("Horaires: ").append(horaireDisponible).append("\n");
        }
        
        sb.append("DÃ©placement possible: ").append(deplacementPossible ? "Oui" : "Non").append("\n");
        
        if (!competences.isEmpty()) {
            sb.append("CompÃ©tences: ").append(String.join(", ", competences)).append("\n");
        }
        
        return sb.toString();
    }
    
    /**
     * Traduit un jour de la semaine en franÃ§ais.
     */
    private String traduireJour(DayOfWeek jour) {
        switch (jour) {
            case MONDAY: return "Lundi";
            case TUESDAY: return "Mardi";
            case WEDNESDAY: return "Mercredi";
            case THURSDAY: return "Jeudi";
            case FRIDAY: return "Vendredi";
            case SATURDAY: return "Samedi";
            case SUNDAY: return "Dimanche";
            default: return jour.toString();
        }
    }
    
    /**
     * Ajoute un jour de disponibilitÃ©.
     * 
     * @param jour Le jour Ã  ajouter
     */
    public void ajouterJourDisponible(DayOfWeek jour) {
        if (!joursDisponibles.contains(jour)) {
            joursDisponibles.add(jour);
        }
    }
    
    /**
     * Ajoute une compÃ©tence.
     * 
     * @param competence La compÃ©tence Ã  ajouter
     */
    public void ajouterCompetence(String competence) {
        if (!competences.contains(competence)) {
            competences.add(competence);
        }
    }
    
    // Getters et Setters spÃ©cifiques
    
    public String getTypeService() {
        return typeService;
    }
    
    public void setTypeService(String typeService) {
        this.typeService = typeService;
    }
    
    public int getDureeMinutesEstimee() {
        return dureeMinutesEstimee;
    }
    
    public void setDureeMinutesEstimee(int dureeMinutesEstimee) {
        this.dureeMinutesEstimee = dureeMinutesEstimee;
    }
    
    public List<DayOfWeek> getJoursDisponibles() {
        return joursDisponibles;
    }
    
    public void setJoursDisponibles(List<DayOfWeek> joursDisponibles) {
        this.joursDisponibles = joursDisponibles;
    }
    
    public String getHoraireDisponible() {
        return horaireDisponible;
    }
    
    public void setHoraireDisponible(String horaireDisponible) {
        this.horaireDisponible = horaireDisponible;
    }
    
    public boolean isDeplacementPossible() {
        return deplacementPossible;
    }
    
    public void setDeplacementPossible(boolean deplacementPossible) {
        this.deplacementPossible = deplacementPossible;
    }
    
    public String getNiveauExpertise() {
        return niveauExpertise;
    }
    
    public void setNiveauExpertise(String niveauExpertise) {
        this.niveauExpertise = niveauExpertise;
    }
    
    public List<String> getCompetences() {
        return competences;
    }
    
    public void setCompetences(List<String> competences) {
        this.competences = competences;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/model/StatutReservation.java
package com.campusshare.model;

/**
 * Ã‰numÃ©ration des diffÃ©rents statuts possibles pour une rÃ©servation.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public enum StatutReservation {
    
    EN_ATTENTE("En attente", "â³"),
    CONFIRMEE("ConfirmÃ©e", "âœ…"),
    EN_COURS("En cours", "ğŸ”„"),
    TERMINEE("TerminÃ©e", "âœ”ï¸"),
    ANNULEE("AnnulÃ©e", "âŒ"),
    REFUSEE("RefusÃ©e", "ğŸš«");
    
    private final String libelle;
    private final String icone;
    
    StatutReservation(String libelle, String icone) {
        this.libelle = libelle;
        this.icone = icone;
    }
    
    public String getLibelle() {
        return libelle;
    }
    
    public String getIcone() {
        return icone;
    }
    
    @Override
    public String toString() {
        return icone + " " + libelle;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/model/Utilisateur.java
package com.campusshare.model;

import com.campusshare.model.annonce.Annonce;
import java.util.ArrayList;
import java.util.List;

/**
 * Classe reprÃ©sentant un utilisateur de l'application CampusShare.
 * Un utilisateur est un Ã©tudiant du campus qui peut publier des annonces,
 * effectuer des rÃ©servations et recevoir des Ã©valuations.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class Utilisateur {
    
    private String id;
    private String nom;
    private String prenom;
    private String email; // Email universitaire (.edu)
    private String motDePasse;
    private double reputation; // Note moyenne (0-5)
    private int nombreEvaluations;
    private List<Annonce> annoncesPubliees;
    private List<Reservation> reservationsEffectuees;
    private List<Evaluation> evaluationsRecues;
    private List<String> categoriesSuivies; // Pour le pattern Observer
    
    /**
     * Constructeur de l'utilisateur.
     * 
     * @param id Identifiant unique
     * @param nom Nom de famille
     * @param prenom PrÃ©nom
     * @param email Email universitaire
     * @param motDePasse Mot de passe hashÃ©
     */
    public Utilisateur(String id, String nom, String prenom, String email, String motDePasse) {
        this.id = id;
        this.nom = nom;
        this.prenom = prenom;
        this.email = email;
        this.motDePasse = motDePasse;
        this.reputation = 0.0;
        this.nombreEvaluations = 0;
        this.annoncesPubliees = new ArrayList<>();
        this.reservationsEffectuees = new ArrayList<>();
        this.evaluationsRecues = new ArrayList<>();
        this.categoriesSuivies = new ArrayList<>();
    }
    
    /**
     * Ajoute une Ã©valuation et met Ã  jour la rÃ©putation.
     * 
     * @param evaluation L'Ã©valuation Ã  ajouter
     */
    public void ajouterEvaluation(Evaluation evaluation) {
        evaluationsRecues.add(evaluation);
        // Recalcul de la moyenne
        double somme = reputation * nombreEvaluations + evaluation.getNote();
        nombreEvaluations++;
        reputation = somme / nombreEvaluations;
    }
    
    /**
     * VÃ©rifie si l'email est un email universitaire valide.
     * 
     * @return true si l'email est valide
     */
    public boolean estEmailUniversitaireValide() {
        return email != null && (email.endsWith(".edu") || 
               email.endsWith(".univ-") || 
               email.contains("@etu.") ||
               email.contains("@student."));
    }
    
    /**
     * Ajoute une catÃ©gorie Ã  suivre (pour les notifications).
     * 
     * @param categorie La catÃ©gorie Ã  suivre
     */
    public void suivreCategorie(String categorie) {
        if (!categoriesSuivies.contains(categorie)) {
            categoriesSuivies.add(categorie);
        }
    }
    
    /**
     * Retire une catÃ©gorie suivie.
     * 
     * @param categorie La catÃ©gorie Ã  ne plus suivre
     */
    public void nePlusSuivreCategorie(String categorie) {
        categoriesSuivies.remove(categorie);
    }
    
    // Getters et Setters
    
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    public String getNom() {
        return nom;
    }
    
    public void setNom(String nom) {
        this.nom = nom;
    }
    
    public String getPrenom() {
        return prenom;
    }
    
    public void setPrenom(String prenom) {
        this.prenom = prenom;
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
    
    public String getMotDePasse() {
        return motDePasse;
    }
    
    public void setMotDePasse(String motDePasse) {
        this.motDePasse = motDePasse;
    }
    
    public double getReputation() {
        return reputation;
    }
    
    public int getNombreEvaluations() {
        return nombreEvaluations;
    }
    
    public List<Annonce> getAnnoncesPubliees() {
        return annoncesPubliees;
    }
    
    public List<Reservation> getReservationsEffectuees() {
        return reservationsEffectuees;
    }
    
    public List<Evaluation> getEvaluationsRecues() {
        return evaluationsRecues;
    }
    
    public List<String> getCategoriesSuivies() {
        return categoriesSuivies;
    }
    
    /**
     * Retourne le nom complet de l'utilisateur.
     * 
     * @return PrÃ©nom + Nom
     */
    public String getNomComplet() {
        return prenom + " " + nom;
    }
    
    @Override
    public String toString() {
        return String.format("Utilisateur[%s] %s %s (%.1fâ˜… - %d avis)", 
                id, prenom, nom, reputation, nombreEvaluations);
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/model/Transaction.java
package com.campusshare.model;

import com.campusshare.paiement.IPaiementStrategy;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

/**
 * Classe reprÃ©sentant une transaction financiÃ¨re entre deux Ã©tudiants.
 * Une transaction utilise une stratÃ©gie de paiement (Strategy Pattern).
 *
 * @author Equipe CampusShare - Member 3
 * @version 1.0
 */
public class Transaction {

    private String id;
    private LocalDateTime dateTransaction;
    private double montant;
    private StatutTransaction statut;
    private String reference;
    private Etudiant emetteur;
    private Etudiant receveur;
    private IPaiementStrategy strategie;

    /**
     * Constructeur de la transaction.
     *
     * @param montant Le montant de la transaction
     * @param emetteur L'Ã©tudiant qui Ã©met le paiement
     * @param receveur L'Ã©tudiant qui reÃ§oit le paiement
     * @param strategie La stratÃ©gie de paiement Ã  utiliser
     */
    public Transaction(double montant, Etudiant emetteur, Etudiant receveur, IPaiementStrategy strategie) {
        this.id = UUID.randomUUID().toString();
        this.dateTransaction = LocalDateTime.now();
        this.montant = montant;
        this.emetteur = emetteur;
        this.receveur = receveur;
        this.strategie = strategie;
        this.statut = StatutTransaction.EN_ATTENTE;
        this.reference = genererReference();
    }

    /**
     * GÃ©nÃ¨re une rÃ©fÃ©rence unique pour la transaction.
     *
     * @return La rÃ©fÃ©rence gÃ©nÃ©rÃ©e
     */
    private String genererReference() {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmmss");
        return "TXN-" + dateTransaction.format(formatter) + "-" + id.substring(0, 8).toUpperCase();
    }

    /**
     * ExÃ©cute la transaction en utilisant la stratÃ©gie de paiement.
     *
     * @return true si la transaction a rÃ©ussi, false sinon
     */
    public boolean executerTransac() {
        System.out.println("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        System.out.println("   EXECUTION DE LA TRANSACTION " + reference);
        System.out.println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        System.out.println("Emetteur: " + emetteur.getNomComplet());
        System.out.println("Receveur: " + receveur.getNomComplet());
        System.out.println("Montant: " + montant);
        System.out.println("StratÃ©gie: " + strategie.getClass().getSimpleName());
        System.out.println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

        boolean succes = strategie.payer(montant, emetteur, receveur);

        if (succes) {
            this.statut = StatutTransaction.VALIDE;
            System.out.println("âœ“ Transaction VALIDEE");
        } else {
            this.statut = StatutTransaction.REFUSE;
            System.out.println("âœ— Transaction REFUSEE");
        }

        System.out.println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
        return succes;
    }

    /**
     * Annule la transaction si elle est en attente.
     *
     * @return true si l'annulation a rÃ©ussi, false sinon
     */
    public boolean annuler() {
        if (statut == StatutTransaction.EN_ATTENTE) {
            statut = StatutTransaction.ANNULE;
            System.out.println("[ANNULATION] Transaction " + reference + " annulÃ©e");
            return true;
        }
        System.out.println("[ERREUR] Impossible d'annuler une transaction avec statut: " + statut);
        return false;
    }

    /**
     * Valide manuellement la transaction.
     *
     * @return true si la validation a rÃ©ussi, false sinon
     */
    public boolean valider() {
        if (statut == StatutTransaction.EN_ATTENTE && strategie.validerPaiement(this)) {
            statut = StatutTransaction.VALIDE;
            System.out.println("[VALIDATION] Transaction " + reference + " validÃ©e");
            return true;
        }
        return false;
    }

    // Getters et Setters

    public String getId() {
        return id;
    }

    public LocalDateTime getDateTransaction() {
        return dateTransaction;
    }

    public double getMontant() {
        return montant;
    }

    public StatutTransaction getStatut() {
        return statut;
    }

    public void setStatut(StatutTransaction statut) {
        this.statut = statut;
    }

    public String getReference() {
        return reference;
    }

    public Etudiant getEmetteur() {
        return emetteur;
    }

    public Etudiant getReceveur() {
        return receveur;
    }

    public IPaiementStrategy getStrategie() {
        return strategie;
    }

    @Override
    public String toString() {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm");
        return String.format("Transaction[%s] %s - %.2f - %s -> %s - Statut: %s",
                reference,
                dateTransaction.format(formatter),
                montant,
                emetteur.getNomComplet(),
                receveur.getNomComplet(),
                statut.getLibelle());
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/TestPaiements.java
package com.campusshare;

import com.campusshare.model.*;
import com.campusshare.model.annonce.*;
import com.campusshare.paiement.*;
import com.campusshare.service.TransactionService;

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *                  TEST COMPLET DU SYSTÃˆME DE PAIEMENTS
 *           Strategy Pattern #1 - Finance & Paiements (Member 3)
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Ce programme teste toutes les fonctionnalitÃ©s du module Finance & Paiements:
 * - T3-01: IPaiementStrategy interface et PaiementGratuit
 * - T3-02: PaiementPoints et PaiementCarteSimule
 * - T3-03: Transaction model et TransactionService
 *
 * @author Equipe CampusShare - Member 3
 * @version 1.0
 */
public class TestPaiements {

    public static void main(String[] args) {
        System.out.println("\n" +
                "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n" +
                "â•‘                                                                       â•‘\n" +
                "â•‘                    ğŸ’³ TEST SYSTÃˆME DE PAIEMENTS                       â•‘\n" +
                "â•‘                   Strategy Pattern #1 (Member 3)                      â•‘\n" +
                "â•‘                                                                       â•‘\n" +
                "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

        // Initialisation
        TestPaiements test = new TestPaiements();

        System.out.println("ğŸ“‹ TESTS PRÃ‰VUS:");
        System.out.println("   1. T3-01: Test PaiementGratuit (toujours rÃ©ussi)");
        System.out.println("   2. T3-02: Test PaiementPoints (Ã©chec si 0 points, succÃ¨s si >= 100)");
        System.out.println("   3. T3-02: Test PaiementCarteSimule (simulation bancaire)");
        System.out.println("   4. T3-03: Test TransactionService (flux complet)");
        System.out.println();

        // ExÃ©cution des tests
        test.testT301_PaiementGratuit();
        test.testT302_PaiementPoints();
        test.testT302_PaiementCarteSimule();
        test.testT303_TransactionServiceFluxComplet();

        // RÃ©sumÃ© final
        test.afficherResume();
    }

    /**
     * TEST T3-01: Paiement Gratuit
     * CritÃ¨re: PaiementGratuit retourne toujours true et affiche un log.
     */
    private void testT301_PaiementGratuit() {
        System.out.println("\n" +
                "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n" +
                "â”‚  TEST T3-01: PAIEMENT GRATUIT (Don)                                 â”‚\n" +
                "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");

        // CrÃ©ation des Ã©tudiants
        Etudiant alice = new Etudiant("E001", "Martin", "Alice",
                "alice@etu.univ.fr", "pass123", "21800001", "Campus Nord");
        Etudiant bob = new Etudiant("E002", "Dupont", "Bob",
                "bob@etu.univ.fr", "pass123", "21800002", "Campus Nord");

        System.out.println("Ã‰tudiants crÃ©Ã©s:");
        System.out.println("â†’ " + alice);
        System.out.println("â†’ " + bob);
        System.out.println();

        // CrÃ©ation d'une annonce de don
        Categorie categorie = new Categorie("CAT004", "Ã‰tudes", "Livres, cours, tutorat", "ğŸ“š");
        DonAnnonce anonceDon = new DonAnnonce(
                "DON001",
                "Livres de programmation Java",
                "Collection de livres Java (Effective Java, Clean Code, Design Patterns)",
                alice,
                categorie
        );
        anonceDon.setEtatObjet("Bon Ã©tat");
        anonceDon.setRaisonDon("DiplÃ´mÃ©, je n'en ai plus besoin");

        System.out.println("Annonce de don crÃ©Ã©e:");
        System.out.println("â†’ " + anonceDon.getTitre());
        System.out.println("â†’ Prix: " + anonceDon.getPrixEstime() + " EUR (gratuit)");
        System.out.println();

        // Test de la stratÃ©gie PaiementGratuit
        IPaiementStrategy strategieGratuit = new PaiementGratuit();
        Transaction transaction = new Transaction(0.0, bob, alice, strategieGratuit);

        boolean resultat = transaction.executerTransac();

        System.out.println("âœ“ TEST T3-01 RÃ‰USSI:");
        System.out.println("   - PaiementGratuit retourne: " + resultat + " (attendu: true)");
        System.out.println("   - Log affichÃ© correctement");
        System.out.println("   - Statut transaction: " + transaction.getStatut());
    }

    /**
     * TEST T3-02: Paiement par Points
     * CritÃ¨res:
     * - Ã‰chec si l'Ã©tudiant a 0 points
     * - SuccÃ¨s si l'Ã©tudiant a 100 points (ou plus selon le montant)
     */
    private void testT302_PaiementPoints() {
        System.out.println("\n" +
                "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n" +
                "â”‚  TEST T3-02: PAIEMENT PAR POINTS                                     â”‚\n" +
                "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");

        // CrÃ©ation des Ã©tudiants
        Etudiant charlie = new Etudiant("E003", "Durand", "Charlie",
                "charlie@etu.univ.fr", "pass123", "21800003", "Campus Sud");
        Etudiant diana = new Etudiant("E004", "Leroy", "Diana",
                "diana@etu.univ.fr", "pass123", "21800004", "Campus Sud");

        // Charlie a 100 points (par dÃ©faut), Diana aussi
        System.out.println("Ã‰tat initial:");
        System.out.println("â†’ " + charlie);
        System.out.println("â†’ " + diana);
        System.out.println();

        // CrÃ©ation d'une annonce de bien
        Categorie categorie = new Categorie("CAT001", "Transport", "VÃ©los, trottinettes", "ğŸš²");
        BienAnnonce annonceVelo = new BienAnnonce(
                "BIEN001",
                "VÃ©lo VTT Rockrider",
                "VTT en bon Ã©tat, 21 vitesses",
                charlie,
                categorie
        );
        annonceVelo.setEtat("Bon Ã©tat");
        annonceVelo.setPrixBase(50.0); // 50 points

        System.out.println("Annonce crÃ©Ã©e:");
        System.out.println("â†’ " + annonceVelo.getTitre());
        System.out.println("â†’ Prix: " + (int)annonceVelo.getPrixEstime() + " points");
        System.out.println();

        // TEST 1: Paiement rÃ©ussi (Diana a 100 points, paie 50)
        System.out.println("--- TEST 1: Ã‰tudiant avec 100 points ---");
        IPaiementStrategy strategiePoints = new PaiementPoints();
        Transaction transaction1 = new Transaction(50.0, diana, charlie, strategiePoints);
        boolean resultat1 = transaction1.executerTransac();

        System.out.println("\nâœ“ TEST 1 RÃ‰USSI:");
        System.out.println("   - Solde Diana avant: 100 points");
        System.out.println("   - Paiement: " + resultat1 + " (attendu: true)");
        System.out.println("   - Solde Diana aprÃ¨s: " + diana.getSoldePoints() + " points");
        System.out.println("   - Solde Charlie aprÃ¨s: " + charlie.getSoldePoints() + " points");

        // TEST 2: Paiement Ã©chouÃ© (Diana a maintenant 50 points, veut payer 60)
        System.out.println("\n--- TEST 2: Solde insuffisant ---");
        BienAnnonce autreAnnonce = new BienAnnonce(
                "BIEN002",
                "Ordinateur portable",
                "MacBook Pro 2020",
                charlie,
                categorie
        );
        autreAnnonce.setEtat("Excellent Ã©tat");
        autreAnnonce.setPrixBase(60.0); // 60 points

        Transaction transaction2 = new Transaction(60.0, diana, charlie, strategiePoints);
        boolean resultat2 = transaction2.executerTransac();

        System.out.println("\nâœ“ TEST 2 RÃ‰USSI:");
        System.out.println("   - Solde Diana: 50 points");
        System.out.println("   - Paiement: " + resultat2 + " (attendu: false)");
        System.out.println("   - Solde inchangÃ©: " + diana.getSoldePoints() + " points");

        // TEST 3: Ã‰tudiant avec 0 points
        System.out.println("\n--- TEST 3: Ã‰tudiant avec 0 points ---");
        Etudiant emma = new Etudiant("E005", "Bernard", "Emma",
                "emma@etu.univ.fr", "pass123", "21800005", "Campus Sud");
        emma.setSoldePoints(0); // Forcer 0 points

        System.out.println("â†’ " + emma);

        Transaction transaction3 = new Transaction(10.0, emma, charlie, strategiePoints);
        boolean resultat3 = transaction3.executerTransac();

        System.out.println("\nâœ“ TEST 3 RÃ‰USSI:");
        System.out.println("   - Solde Emma: 0 points");
        System.out.println("   - Paiement: " + resultat3 + " (attendu: false)");
        System.out.println("   - CritÃ¨re d'acceptation validÃ©: Ã©chec si 0 points");
    }

    /**
     * TEST T3-02: Paiement par Carte Bancaire SimulÃ©
     */
    private void testT302_PaiementCarteSimule() {
        System.out.println("\n" +
                "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n" +
                "â”‚  TEST T3-02: PAIEMENT PAR CARTE BANCAIRE SIMULÃ‰                     â”‚\n" +
                "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");

        // CrÃ©ation des Ã©tudiants
        Etudiant alice = new Etudiant("E001", "Martin", "Alice",
                "alice@etu.univ.fr", "pass123", "21800001", "Campus Nord");
        Etudiant frank = new Etudiant("E006", "Moreau", "Frank",
                "frank@etu.univ.fr", "pass123", "21800006", "Campus Nord");

        System.out.println("Ã‰tudiants crÃ©Ã©s:");
        System.out.println("â†’ " + alice);
        System.out.println("â†’ " + frank);
        System.out.println();

        // CrÃ©ation d'une annonce de service
        Categorie categorie = new Categorie("CAT004", "Ã‰tudes", "Cours et tutorat", "ğŸ“š");
        ServiceAnnonce annonceService = new ServiceAnnonce(
                "SERV001",
                "Cours de MathÃ©matiques",
                "Cours particuliers de maths niveau L1-L2",
                alice,
                categorie
        );
        annonceService.setTypeService("Tutorat");
        annonceService.setPrixBase(25.0); // 25 EUR/heure
        annonceService.setDureeMinutesEstimee(60); // 1 heure

        System.out.println("Annonce de service crÃ©Ã©e:");
        System.out.println("â†’ " + annonceService.getTitre());
        System.out.println("â†’ Prix: " + annonceService.getPrixEstime() + " EUR");
        System.out.println();

        // Test de la stratÃ©gie PaiementCarteSimule
        IPaiementStrategy strategieCarte = new PaiementCarteSimule();
        Transaction transaction = new Transaction(25.0, frank, alice, strategieCarte);

        System.out.println("Solde points initial (Frank): " + frank.getSoldePoints());
        System.out.println("Solde points initial (Alice): " + alice.getSoldePoints());
        System.out.println();

        boolean resultat = transaction.executerTransac();

        System.out.println("\nâœ“ TEST T3-02 RÃ‰USSI:");
        System.out.println("   - Simulation bancaire effectuÃ©e");
        System.out.println("   - RÃ©sultat: " + resultat);
        System.out.println("   - Statut: " + transaction.getStatut());
        if (resultat) {
            System.out.println("   - Points bonus vendeur: " + (alice.getSoldePoints() - 100) + " pts");
        }
    }

    /**
     * TEST T3-03: TransactionService - Flux complet
     * CritÃ¨res:
     * - Le service prend Annonce + Acheteur + StratÃ©gie
     * - ExÃ©cute le paiement
     * - CrÃ©e un enregistrement Transaction
     * - Met Ã  jour le solde de l'Ã©tudiant
     */
    private void testT303_TransactionServiceFluxComplet() {
        System.out.println("\n" +
                "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n" +
                "â”‚  TEST T3-03: TRANSACTION SERVICE - FLUX COMPLET                      â”‚\n" +
                "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");

        // CrÃ©ation du service
        TransactionService transactionService = new TransactionService();

        // CrÃ©ation des Ã©tudiants
        Etudiant vendeur = new Etudiant("E007", "Petit", "Gabriel",
                "gabriel@etu.univ.fr", "pass123", "21800007", "Campus Est");
        Etudiant acheteur = new Etudiant("E008", "Roux", "HÃ©lÃ¨ne",
                "helene@etu.univ.fr", "pass123", "21800008", "Campus Est");

        System.out.println("Participants Ã  la transaction:");
        System.out.println("â†’ Vendeur: " + vendeur);
        System.out.println("â†’ Acheteur: " + acheteur);
        System.out.println();

        // CrÃ©ation d'une annonce
        Categorie categorie = new Categorie("CAT002", "High-Tech", "Ã‰lectronique", "ğŸ’»");
        BienAnnonce annonceTablette = new BienAnnonce(
                "BIEN003",
                "iPad Pro 11 pouces",
                "iPad Pro en excellent Ã©tat, avec clavier et stylet Apple Pencil",
                vendeur,
                categorie
        );
        annonceTablette.setEtat("Excellent Ã©tat");
        annonceTablette.setPrixBase(80.0); // 80 points

        System.out.println("Annonce crÃ©Ã©e:");
        System.out.println("â†’ " + annonceTablette.getTitre());
        System.out.println("â†’ Prix: " + (int)annonceTablette.getPrixEstime() + " points");
        System.out.println("â†’ Disponible: " + annonceTablette.estDisponible());
        System.out.println();

        // FLUX COMPLET avec TransactionService
        System.out.println("--- EXÃ‰CUTION DU FLUX COMPLET ---");
        System.out.println("Ã‰tat AVANT transaction:");
        System.out.println("â†’ Solde acheteur: " + acheteur.getSoldePoints() + " points");
        System.out.println("â†’ Solde vendeur: " + vendeur.getSoldePoints() + " points");
        System.out.println("â†’ Annonce disponible: " + annonceTablette.estDisponible());
        System.out.println();

        // Effectuer la transaction via le service
        IPaiementStrategy strategiePoints = new PaiementPoints();
        Transaction transaction = transactionService.effectuerTransaction(
                annonceTablette,
                acheteur,
                strategiePoints
        );

        System.out.println("\nÃ‰tat APRÃˆS transaction:");
        System.out.println("â†’ Solde acheteur: " + acheteur.getSoldePoints() + " points");
        System.out.println("â†’ Solde vendeur: " + vendeur.getSoldePoints() + " points");
        System.out.println("â†’ Annonce disponible: " + annonceTablette.estDisponible());
        System.out.println();

        // VÃ©rification de l'historique
        System.out.println("--- VÃ‰RIFICATION HISTORIQUE ---");
        transactionService.afficherHistorique();

        System.out.println("âœ“ TEST T3-03 RÃ‰USSI:");
        System.out.println("   - Transaction crÃ©Ã©e: " + (transaction != null));
        System.out.println("   - Paiement exÃ©cutÃ©: " + (transaction != null && transaction.getStatut().toString().equals("ValidÃ©e")));
        System.out.println("   - Solde mis Ã  jour: " + (acheteur.getSoldePoints() == 20));
        System.out.println("   - Annonce mise Ã  jour: " + (!annonceTablette.estDisponible()));
        System.out.println("   - Historique enregistrÃ©: " + (transactionService.getHistoriqueTransactions().size() == 1));
    }

    /**
     * Affiche le rÃ©sumÃ© final des tests.
     */
    private void afficherResume() {
        System.out.println("\n" +
                "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n" +
                "â•‘                         âœ… RÃ‰SUMÃ‰ DES TESTS                           â•‘\n" +
                "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

        System.out.println("ğŸ“Š Tous les tests ont rÃ©ussi:\n");

        System.out.println("   âœ“ T3-01: IPaiementStrategy & PaiementGratuit");
        System.out.println("     â†’ Interface correctement dÃ©finie");
        System.out.println("     â†’ PaiementGratuit retourne toujours true");
        System.out.println("     â†’ Logs affichÃ©s correctement");

        System.out.println("\n   âœ“ T3-02: PaiementPoints");
        System.out.println("     â†’ Ã‰chec si Ã©tudiant a 0 points âœ“");
        System.out.println("     â†’ SuccÃ¨s si Ã©tudiant a >= 100 points âœ“");
        System.out.println("     â†’ DÃ©bite et crÃ©dite correctement les points");

        System.out.println("\n   âœ“ T3-02: PaiementCarteSimule");
        System.out.println("     â†’ Simulation bancaire fonctionnelle");
        System.out.println("     â†’ Points bonus attribuÃ©s au vendeur");
        System.out.println("     â†’ Gestion du taux de rÃ©ussite simulÃ©");

        System.out.println("\n   âœ“ T3-03: Transaction & TransactionService");
        System.out.println("     â†’ Transaction crÃ©Ã©e avec stratÃ©gie");
        System.out.println("     â†’ Flux complet: Annonce + Acheteur + StratÃ©gie");
        System.out.println("     â†’ Mise Ã  jour du solde Ã©tudiant");
        System.out.println("     â†’ Historique des transactions");
        System.out.println("     â†’ Annonce marquÃ©e comme non disponible");

        System.out.println("\nğŸ“Œ Design Pattern implÃ©mentÃ©:\n");
        System.out.println("   ğŸ¯ STRATEGY PATTERN #1 (Finance & Paiements)");
        System.out.println("      â†’ 3 stratÃ©gies de paiement interchangeables:");
        System.out.println("        â€¢ PaiementGratuit (pour les dons)");
        System.out.println("        â€¢ PaiementPoints (monnaie virtuelle campus)");
        System.out.println("        â€¢ PaiementCarteSimule (paiement bancaire)");

        System.out.println("\nğŸ“Œ Classes crÃ©Ã©es:\n");
        System.out.println("   â€¢ Model:");
        System.out.println("     - Etudiant (extends Utilisateur)");
        System.out.println("     - Transaction");
        System.out.println("     - StatutTransaction (enum)");
        System.out.println("   â€¢ Paiement (Strategy Pattern):");
        System.out.println("     - IPaiementStrategy (interface)");
        System.out.println("     - PaiementGratuit");
        System.out.println("     - PaiementPoints");
        System.out.println("     - PaiementCarteSimule");
        System.out.println("   â€¢ Service:");
        System.out.println("     - TransactionService");

        System.out.println("\n" +
                "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" +
                "             ğŸ‰ TOUS LES CRITÃˆRES D'ACCEPTATION VALIDÃ‰S ğŸ‰                \n" +
                "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/service/ReservationService.java
package com.campusshare.service;

import com.campusshare.adapter.Calendrier;
import com.campusshare.model.*;
import com.campusshare.model.annonce.Annonce;
import com.campusshare.strategy.*;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Service de gestion des rÃ©servations.
 * 
 * Utilise:
 * - Pattern Strategy pour le calcul des prix
 * - Pattern Adapter pour l'intÃ©gration calendrier
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class ReservationService {
    
    private List<Reservation> reservations;
    private Calendrier calendrier; // Pattern Adapter - optionnel
    
    /**
     * Constructeur du service.
     */
    public ReservationService() {
        this.reservations = new ArrayList<>();
    }
    
    /**
     * Constructeur avec calendrier externe.
     * 
     * @param calendrier Adaptateur de calendrier
     */
    public ReservationService(Calendrier calendrier) {
        this();
        this.calendrier = calendrier;
    }
    
    // ==================== CrÃ©ation de rÃ©servations ====================
    
    /**
     * CrÃ©e une rÃ©servation avec une stratÃ©gie de tarification spÃ©cifique.
     * Pattern Strategy en action.
     * 
     * @param annonce L'annonce Ã  rÃ©server
     * @param demandeur L'utilisateur qui rÃ©serve
     * @param dateDebut Date de dÃ©but
     * @param dateFin Date de fin
     * @param strategy StratÃ©gie de tarification
     * @return La rÃ©servation crÃ©Ã©e
     */
    public Reservation creerReservation(Annonce annonce, Utilisateur demandeur,
                                         LocalDateTime dateDebut, LocalDateTime dateFin,
                                         StrategyTarification strategy) {
        // Validation
        if (!annonce.estDisponible()) {
            throw new IllegalStateException("Cette annonce n'est pas disponible");
        }
        
        if (demandeur.equals(annonce.getProprietaire())) {
            throw new IllegalArgumentException("Vous ne pouvez pas rÃ©server votre propre annonce");
        }
        
        // CrÃ©ation de la rÃ©servation avec la stratÃ©gie
        String id = genererIdReservation();
        Reservation reservation = new Reservation(id, annonce, demandeur, 
                dateDebut, dateFin, strategy);
        
        reservations.add(reservation);
        demandeur.getReservationsEffectuees().add(reservation);
        
        // Notification au propriÃ©taire via le pattern Observer (si configurÃ©)
        annonce.notifyObservers(String.format(
                "Nouvelle demande de rÃ©servation de %s pour '%s'",
                demandeur.getNomComplet(),
                annonce.getTitre()
        ));
        
        System.out.println("âœ… RÃ©servation crÃ©Ã©e: " + id);
        System.out.println("   StratÃ©gie: " + strategy.getNom());
        System.out.println("   Prix calculÃ©: " + String.format("%.2fâ‚¬", reservation.getPrixTotal()));
        
        return reservation;
    }
    
    /**
     * CrÃ©e une rÃ©servation avec tarif horaire.
     */
    public Reservation reserverAvecTarifHoraire(Annonce annonce, Utilisateur demandeur,
                                                 LocalDateTime dateDebut, LocalDateTime dateFin) {
        return creerReservation(annonce, demandeur, dateDebut, dateFin, new TarifHoraire());
    }
    
    /**
     * CrÃ©e une rÃ©servation avec tarif journalier.
     */
    public Reservation reserverAvecTarifJournalier(Annonce annonce, Utilisateur demandeur,
                                                    LocalDateTime dateDebut, LocalDateTime dateFin) {
        return creerReservation(annonce, demandeur, dateDebut, dateFin, new TarifJournalier());
    }
    
    /**
     * CrÃ©e une rÃ©servation gratuite.
     */
    public Reservation reserverGratuit(Annonce annonce, Utilisateur demandeur,
                                        LocalDateTime dateDebut, LocalDateTime dateFin) {
        return creerReservation(annonce, demandeur, dateDebut, dateFin, new TarifGratuit());
    }
    
    /**
     * CrÃ©e une rÃ©servation forfaitaire.
     */
    public Reservation reserverForfait(Annonce annonce, Utilisateur demandeur,
                                        LocalDateTime dateDebut, LocalDateTime dateFin) {
        return creerReservation(annonce, demandeur, dateDebut, dateFin, new TarifForfaitaire());
    }
    
    // ==================== Gestion du cycle de vie ====================
    
    /**
     * Confirme une rÃ©servation et l'ajoute au calendrier si disponible.
     */
    public void confirmerReservation(Reservation reservation) {
        reservation.confirmer();
        
        // Marquer l'annonce comme rÃ©servÃ©e
        reservation.getAnnonce().changerStatut(StatutAnnonce.RESERVEE);
        
        // IntÃ©gration calendrier via l'Adapter
        if (calendrier != null) {
            calendrier.ajouterEvenement(reservation);
        }
        
        // Notification
        reservation.getAnnonce().notifyObservers(
                "RÃ©servation confirmÃ©e pour: " + reservation.getAnnonce().getTitre()
        );
        
        System.out.println("âœ… RÃ©servation confirmÃ©e: " + reservation.getId());
    }
    
    /**
     * DÃ©marre une rÃ©servation (le bien est remis / le service commence).
     */
    public void demarrerReservation(Reservation reservation) {
        reservation.demarrer();
        System.out.println("ğŸ”„ RÃ©servation dÃ©marrÃ©e: " + reservation.getId());
    }
    
    /**
     * Termine une rÃ©servation.
     */
    public void terminerReservation(Reservation reservation) {
        reservation.terminer();
        
        // Rendre l'annonce Ã  nouveau disponible
        reservation.getAnnonce().changerStatut(StatutAnnonce.ACTIVE);
        
        // Supprimer du calendrier
        if (calendrier != null) {
            calendrier.supprimerEvenement(reservation.getId());
        }
        
        System.out.println("âœ”ï¸ RÃ©servation terminÃ©e: " + reservation.getId());
    }
    
    /**
     * Annule une rÃ©servation.
     */
    public void annulerReservation(Reservation reservation) {
        reservation.annuler();
        
        // Rendre l'annonce disponible si elle Ã©tait rÃ©servÃ©e
        if (reservation.getAnnonce().getStatut() == StatutAnnonce.RESERVEE) {
            reservation.getAnnonce().changerStatut(StatutAnnonce.ACTIVE);
        }
        
        // Supprimer du calendrier
        if (calendrier != null) {
            calendrier.supprimerEvenement(reservation.getId());
        }
        
        // Notification
        reservation.getAnnonce().notifyObservers(
                "RÃ©servation annulÃ©e pour: " + reservation.getAnnonce().getTitre()
        );
        
        System.out.println("âŒ RÃ©servation annulÃ©e: " + reservation.getId());
    }
    
    /**
     * Refuse une rÃ©servation.
     */
    public void refuserReservation(Reservation reservation) {
        reservation.refuser();
        System.out.println("ğŸš« RÃ©servation refusÃ©e: " + reservation.getId());
    }
    
    // ==================== Recherche ====================
    
    /**
     * Trouve une rÃ©servation par son ID.
     */
    public Reservation trouverParId(String id) {
        return reservations.stream()
                .filter(r -> r.getId().equals(id))
                .findFirst()
                .orElse(null);
    }
    
    /**
     * Retourne les rÃ©servations d'un demandeur.
     */
    public List<Reservation> getReservationsDemandeur(Utilisateur demandeur) {
        return reservations.stream()
                .filter(r -> r.getDemandeur().equals(demandeur))
                .collect(Collectors.toList());
    }
    
    /**
     * Retourne les rÃ©servations pour les annonces d'un propriÃ©taire.
     */
    public List<Reservation> getReservationsProprietaire(Utilisateur proprietaire) {
        return reservations.stream()
                .filter(r -> r.getProprietaire().equals(proprietaire))
                .collect(Collectors.toList());
    }
    
    /**
     * Retourne les rÃ©servations en attente pour un propriÃ©taire.
     */
    public List<Reservation> getReservationsEnAttente(Utilisateur proprietaire) {
        return reservations.stream()
                .filter(r -> r.getProprietaire().equals(proprietaire))
                .filter(r -> r.getStatut() == StatutReservation.EN_ATTENTE)
                .collect(Collectors.toList());
    }
    
    /**
     * Retourne les rÃ©servations par statut.
     */
    public List<Reservation> getReservationsParStatut(StatutReservation statut) {
        return reservations.stream()
                .filter(r -> r.getStatut() == statut)
                .collect(Collectors.toList());
    }
    
    // ==================== Utilitaires ====================
    
    /**
     * GÃ©nÃ¨re un ID unique pour une rÃ©servation.
     */
    private String genererIdReservation() {
        return "RES-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();
    }
    
    /**
     * Change la stratÃ©gie de tarification d'une rÃ©servation et recalcule le prix.
     */
    public void changerStrategie(Reservation reservation, StrategyTarification nouvelleStrategy) {
        System.out.println("ğŸ”„ Changement de stratÃ©gie de tarification...");
        System.out.println("   Ancienne stratÃ©gie: " + reservation.getStrategyTarification().getNom());
        System.out.println("   Ancien prix: " + String.format("%.2fâ‚¬", reservation.getPrixTotal()));
        
        reservation.setStrategyTarification(nouvelleStrategy);
        
        System.out.println("   Nouvelle stratÃ©gie: " + nouvelleStrategy.getNom());
        System.out.println("   Nouveau prix: " + String.format("%.2fâ‚¬", reservation.getPrixTotal()));
    }
    
    // ==================== Getters/Setters ====================
    
    public List<Reservation> getReservations() {
        return reservations;
    }
    
    public Calendrier getCalendrier() {
        return calendrier;
    }
    
    public void setCalendrier(Calendrier calendrier) {
        this.calendrier = calendrier;
    }
    
    public int getNombreReservations() {
        return reservations.size();
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/service/TransactionService.java
package com.campusshare.service;

import com.campusshare.model.Etudiant;
import com.campusshare.model.Transaction;
import com.campusshare.model.annonce.Annonce;
import com.campusshare.paiement.IPaiementStrategy;
import java.util.ArrayList;
import java.util.List;

/**
 * Service de gestion des transactions financiÃ¨res.
 * Ce service orchestre la crÃ©ation et l'exÃ©cution des transactions
 * en utilisant diffÃ©rentes stratÃ©gies de paiement.
 *
 * @author Equipe CampusShare - Member 3
 * @version 1.0
 */
public class TransactionService {

    private List<Transaction> historiqueTransactions;

    /**
     * Constructeur du service de transactions.
     */
    public TransactionService() {
        this.historiqueTransactions = new ArrayList<>();
    }

    /**
     * CrÃ©e et exÃ©cute une transaction pour une annonce donnÃ©e.
     * Cette mÃ©thode prend en charge le flux complet de paiement :
     * 1. CrÃ©ation de la transaction
     * 2. ExÃ©cution du paiement via la stratÃ©gie
     * 3. Enregistrement dans l'historique
     *
     * @param annonce L'annonce concernÃ©e par la transaction
     * @param acheteur L'Ã©tudiant qui achÃ¨te/demande
     * @param strategie La stratÃ©gie de paiement Ã  utiliser
     * @return La transaction crÃ©Ã©e, ou null si l'exÃ©cution a Ã©chouÃ©
     */
    public Transaction effectuerTransaction(Annonce annonce, Etudiant acheteur, IPaiementStrategy strategie) {
        System.out.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        System.out.println("â•‘   NOUVEAU PROCESSUS DE TRANSACTION            â•‘");
        System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        System.out.println("Annonce: " + annonce.getTitre());
        System.out.println("Vendeur: " + annonce.getAuteur().getNomComplet());
        System.out.println("Acheteur: " + acheteur.getNomComplet());
        System.out.println();

        // RÃ©cupÃ©ration du vendeur depuis l'annonce
        Etudiant vendeur = (Etudiant) annonce.getAuteur();

        // VÃ©rification que l'acheteur n'est pas le vendeur
        if (acheteur.getId().equals(vendeur.getId())) {
            System.out.println("âœ— ERREUR: Impossible d'acheter sa propre annonce");
            return null;
        }

        // Calcul du montant basÃ© sur le type d'annonce
        double montant = annonce.getPrixEstime();

        // CrÃ©ation de la transaction
        Transaction transaction = new Transaction(montant, acheteur, vendeur, strategie);

        // ExÃ©cution de la transaction
        boolean succes = transaction.executerTransac();

        if (succes) {
            // Ajout Ã  l'historique
            historiqueTransactions.add(transaction);

            // Mise Ã  jour de la disponibilitÃ© de l'annonce
            annonce.setEstDisponible(false);

            System.out.println("âœ“ Transaction enregistrÃ©e dans l'historique");
            System.out.println("âœ“ Annonce marquÃ©e comme non disponible");

            return transaction;
        } else {
            System.out.println("âœ— La transaction a Ã©chouÃ© et n'a pas Ã©tÃ© enregistrÃ©e");
            return null;
        }
    }

    /**
     * RÃ©cupÃ¨re l'historique complet des transactions.
     *
     * @return La liste de toutes les transactions
     */
    public List<Transaction> getHistoriqueTransactions() {
        return new ArrayList<>(historiqueTransactions);
    }

    /**
     * RÃ©cupÃ¨re les transactions d'un Ã©tudiant spÃ©cifique (Ã©metteur ou receveur).
     *
     * @param etudiant L'Ã©tudiant concernÃ©
     * @return La liste des transactions liÃ©es Ã  cet Ã©tudiant
     */
    public List<Transaction> getTransactionsEtudiant(Etudiant etudiant) {
        List<Transaction> transactions = new ArrayList<>();

        for (Transaction t : historiqueTransactions) {
            if (t.getEmetteur().getId().equals(etudiant.getId()) ||
                t.getReceveur().getId().equals(etudiant.getId())) {
                transactions.add(t);
            }
        }

        return transactions;
    }

    /**
     * Affiche l'historique complet des transactions.
     */
    public void afficherHistorique() {
        System.out.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        System.out.println("â•‘   HISTORIQUE DES TRANSACTIONS                 â•‘");
        System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

        if (historiqueTransactions.isEmpty()) {
            System.out.println("Aucune transaction enregistrÃ©e.");
        } else {
            System.out.println("Nombre total de transactions: " + historiqueTransactions.size());
            System.out.println();

            for (int i = 0; i < historiqueTransactions.size(); i++) {
                Transaction t = historiqueTransactions.get(i);
                System.out.println((i + 1) + ". " + t.toString());
            }
        }

        System.out.println();
    }

    /**
     * Calcule le montant total des transactions rÃ©ussies.
     *
     * @return Le montant total
     */
    public double calculerMontantTotal() {
        return historiqueTransactions.stream()
                .filter(t -> t.getStatut().toString().equals("ValidÃ©e"))
                .mapToDouble(Transaction::getMontant)
                .sum();
    }

    /**
     * Compte le nombre de transactions rÃ©ussies.
     *
     * @return Le nombre de transactions validÃ©es
     */
    public int compterTransactionsReussies() {
        return (int) historiqueTransactions.stream()
                .filter(t -> t.getStatut().toString().equals("ValidÃ©e"))
                .count();
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/service/AnnonceService.java
package com.campusshare.service;

import com.campusshare.factory.AnnonceFactory;
import com.campusshare.model.Categorie;
import com.campusshare.model.StatutAnnonce;
import com.campusshare.model.Utilisateur;
import com.campusshare.model.annonce.*;
import com.campusshare.observer.Observer;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Service de gestion des annonces.
 * Centralise toutes les opÃ©rations sur les annonces.
 * 
 * Utilise:
 * - Pattern Simple Factory pour la crÃ©ation d'annonces
 * - Pattern Observer pour les notifications
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class AnnonceService {
    
    private List<Annonce> annonces;
    private List<Observer> observersGlobaux; // Observateurs pour toutes les nouvelles annonces
    
    /**
     * Constructeur du service.
     */
    public AnnonceService() {
        this.annonces = new ArrayList<>();
        this.observersGlobaux = new ArrayList<>();
    }
    
    // ==================== CrÃ©ation d'annonces (utilise Factory) ====================
    
    /**
     * CrÃ©e et publie une nouvelle annonce en utilisant la Factory.
     * 
     * @param type Type d'annonce
     * @param titre Titre
     * @param description Description
     * @param proprietaire PropriÃ©taire
     * @param categorie CatÃ©gorie
     * @return L'annonce crÃ©Ã©e
     */
    public Annonce publierAnnonce(TypeAnnonce type, String titre, String description,
                                   Utilisateur proprietaire, Categorie categorie) {
        // Utilisation du Pattern Simple Factory
        Annonce annonce = AnnonceFactory.creerAnnonce(type, titre, description, 
                proprietaire, categorie);
        
        // Ajout des observateurs globaux
        for (Observer observer : observersGlobaux) {
            annonce.attach(observer);
        }
        
        annonces.add(annonce);
        proprietaire.getAnnoncesPubliees().add(annonce);
        
        // Notification des observateurs globaux
        annonce.notifyObservers("Nouvelle annonce publiÃ©e: " + titre);
        
        return annonce;
    }
    
    /**
     * CrÃ©e une annonce de bien avec paramÃ¨tres dÃ©taillÃ©s.
     */
    public BienAnnonce publierBien(String titre, String description,
                                    Utilisateur proprietaire, Categorie categorie,
                                    String etat, double prixBase) {
        BienAnnonce annonce = AnnonceFactory.creerAnnonceBien(titre, description, 
                proprietaire, categorie, etat, prixBase);
        
        for (Observer observer : observersGlobaux) {
            annonce.attach(observer);
        }
        
        annonces.add(annonce);
        proprietaire.getAnnoncesPubliees().add(annonce);
        annonce.notifyObservers("Nouveau bien Ã  louer: " + titre);
        
        return annonce;
    }
    
    /**
     * CrÃ©e une annonce de service avec paramÃ¨tres dÃ©taillÃ©s.
     */
    public ServiceAnnonce publierService(String titre, String description,
                                          Utilisateur proprietaire, Categorie categorie,
                                          String typeService, double prixBase, int dureeMinutes) {
        ServiceAnnonce annonce = AnnonceFactory.creerAnnonceService(titre, description, 
                proprietaire, categorie, typeService, prixBase, dureeMinutes);
        
        for (Observer observer : observersGlobaux) {
            annonce.attach(observer);
        }
        
        annonces.add(annonce);
        proprietaire.getAnnoncesPubliees().add(annonce);
        annonce.notifyObservers("Nouveau service disponible: " + titre);
        
        return annonce;
    }
    
    /**
     * CrÃ©e une annonce de don avec paramÃ¨tres dÃ©taillÃ©s.
     */
    public DonAnnonce publierDon(String titre, String description,
                                  Utilisateur proprietaire, Categorie categorie,
                                  String etatObjet, String raisonDon) {
        DonAnnonce annonce = AnnonceFactory.creerAnnonceDon(titre, description, 
                proprietaire, categorie, etatObjet, raisonDon);
        
        for (Observer observer : observersGlobaux) {
            annonce.attach(observer);
        }
        
        annonces.add(annonce);
        proprietaire.getAnnoncesPubliees().add(annonce);
        annonce.notifyObservers("Nouveau don disponible: " + titre);
        
        return annonce;
    }
    
    // ==================== Recherche et filtrage ====================
    
    /**
     * Recherche des annonces par mot-clÃ© dans le titre ou la description.
     */
    public List<Annonce> rechercherParMotCle(String motCle) {
        String motCleLower = motCle.toLowerCase();
        return annonces.stream()
                .filter(a -> a.getStatut() == StatutAnnonce.ACTIVE)
                .filter(a -> a.getTitre().toLowerCase().contains(motCleLower) ||
                            a.getDescription().toLowerCase().contains(motCleLower))
                .collect(Collectors.toList());
    }
    
    /**
     * Filtre les annonces par catÃ©gorie.
     */
    public List<Annonce> filtrerParCategorie(Categorie categorie) {
        return annonces.stream()
                .filter(a -> a.getStatut() == StatutAnnonce.ACTIVE)
                .filter(a -> a.getCategorie().equals(categorie))
                .collect(Collectors.toList());
    }
    
    /**
     * Filtre les annonces par type.
     */
    public List<Annonce> filtrerParType(TypeAnnonce type) {
        return annonces.stream()
                .filter(a -> a.getStatut() == StatutAnnonce.ACTIVE)
                .filter(a -> a.getType() == type)
                .collect(Collectors.toList());
    }
    
    /**
     * Filtre les annonces par prix maximum.
     */
    public List<Annonce> filtrerParPrixMax(double prixMax) {
        return annonces.stream()
                .filter(a -> a.getStatut() == StatutAnnonce.ACTIVE)
                .filter(a -> a.getPrixBase() <= prixMax)
                .collect(Collectors.toList());
    }
    
    /**
     * Retourne les annonces d'un utilisateur.
     */
    public List<Annonce> getAnnoncesUtilisateur(Utilisateur utilisateur) {
        return annonces.stream()
                .filter(a -> a.getProprietaire().equals(utilisateur))
                .collect(Collectors.toList());
    }
    
    /**
     * Retourne toutes les annonces actives.
     */
    public List<Annonce> getAnnoncesActives() {
        return annonces.stream()
                .filter(a -> a.getStatut() == StatutAnnonce.ACTIVE)
                .collect(Collectors.toList());
    }
    
    // ==================== Gestion des annonces ====================
    
    /**
     * Supprime une annonce (change son statut).
     */
    public void supprimerAnnonce(Annonce annonce) {
        annonce.changerStatut(StatutAnnonce.SUPPRIMEE);
    }
    
    /**
     * Marque une annonce comme rÃ©servÃ©e.
     */
    public void marquerReservee(Annonce annonce) {
        annonce.changerStatut(StatutAnnonce.RESERVEE);
    }
    
    /**
     * Rend une annonce Ã  nouveau disponible.
     */
    public void rendreDisponible(Annonce annonce) {
        annonce.changerStatut(StatutAnnonce.ACTIVE);
    }
    
    /**
     * Trouve une annonce par son ID.
     */
    public Annonce trouverParId(String id) {
        return annonces.stream()
                .filter(a -> a.getId().equals(id))
                .findFirst()
                .orElse(null);
    }
    
    // ==================== Gestion des observateurs globaux ====================
    
    /**
     * Ajoute un observateur global (notifiÃ© pour toutes les annonces).
     */
    public void ajouterObservateurGlobal(Observer observer) {
        observersGlobaux.add(observer);
        // Attache aussi aux annonces existantes
        for (Annonce annonce : annonces) {
            annonce.attach(observer);
        }
    }
    
    /**
     * Retire un observateur global.
     */
    public void retirerObservateurGlobal(Observer observer) {
        observersGlobaux.remove(observer);
        for (Annonce annonce : annonces) {
            annonce.detach(observer);
        }
    }
    
    // ==================== Getters ====================
    
    public List<Annonce> getAnnonces() {
        return annonces;
    }
    
    public int getNombreAnnonces() {
        return annonces.size();
    }
    
    public int getNombreAnnoncesActives() {
        return (int) annonces.stream()
                .filter(a -> a.getStatut() == StatutAnnonce.ACTIVE)
                .count();
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/service/EvaluationService.java
package com.campusshare.service;

import com.campusshare.model.Evaluation;
import com.campusshare.model.Reservation;
import com.campusshare.model.StatutReservation;
import com.campusshare.model.Utilisateur;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Service de gestion des Ã©valuations.
 * Permet aux utilisateurs de s'Ã©valuer mutuellement aprÃ¨s une transaction.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class EvaluationService {
    
    private List<Evaluation> evaluations;
    
    /**
     * Constructeur du service.
     */
    public EvaluationService() {
        this.evaluations = new ArrayList<>();
    }
    
    /**
     * CrÃ©e une Ã©valuation aprÃ¨s une rÃ©servation terminÃ©e.
     * 
     * @param reservation La rÃ©servation concernÃ©e
     * @param evaluateur Celui qui Ã©value
     * @param note Note de 1 Ã  5
     * @param commentaire Commentaire
     * @return L'Ã©valuation crÃ©Ã©e
     */
    public Evaluation evaluer(Reservation reservation, Utilisateur evaluateur,
                               int note, String commentaire) {
        
        // VÃ©rifications
        if (!reservation.peutEtreEvaluee()) {
            throw new IllegalStateException(
                    "La rÃ©servation doit Ãªtre terminÃ©e pour Ãªtre Ã©valuÃ©e");
        }
        
        if (note < 1 || note > 5) {
            throw new IllegalArgumentException("La note doit Ãªtre entre 1 et 5");
        }
        
        // DÃ©terminer qui est Ã©valuÃ©
        Utilisateur evaluer;
        if (evaluateur.equals(reservation.getDemandeur())) {
            evaluer = reservation.getProprietaire();
        } else if (evaluateur.equals(reservation.getProprietaire())) {
            evaluer = reservation.getDemandeur();
        } else {
            throw new IllegalArgumentException(
                    "L'Ã©valuateur doit Ãªtre participant Ã  la rÃ©servation");
        }
        
        // VÃ©rifier que l'Ã©valuateur n'a pas dÃ©jÃ  Ã©valuÃ© cette rÃ©servation
        if (aDejaEvalue(evaluateur, reservation)) {
            throw new IllegalStateException("Vous avez dÃ©jÃ  Ã©valuÃ© cette rÃ©servation");
        }
        
        // CrÃ©er l'Ã©valuation
        String id = genererIdEvaluation();
        Evaluation evaluation = new Evaluation(id, evaluateur, evaluer, 
                note, commentaire, reservation.getId());
        
        evaluations.add(evaluation);
        
        // Mettre Ã  jour la rÃ©putation de l'utilisateur Ã©valuÃ©
        evaluer.ajouterEvaluation(evaluation);
        
        System.out.println("â­ Ã‰valuation crÃ©Ã©e:");
        System.out.println("   " + evaluateur.getNomComplet() + " â†’ " + evaluer.getNomComplet());
        System.out.println("   " + evaluation.getNoteEnEtoiles());
        System.out.println("   \"" + commentaire + "\"");
        System.out.println("   Nouvelle rÃ©putation de " + evaluer.getNomComplet() + 
                ": " + String.format("%.2f", evaluer.getReputation()) + "â˜…");
        
        return evaluation;
    }
    
    /**
     * Ã‰valuation rapide du propriÃ©taire par le demandeur.
     */
    public Evaluation evaluerProprietaire(Reservation reservation, int note, String commentaire) {
        return evaluer(reservation, reservation.getDemandeur(), note, commentaire);
    }
    
    /**
     * Ã‰valuation rapide du demandeur par le propriÃ©taire.
     */
    public Evaluation evaluerDemandeur(Reservation reservation, int note, String commentaire) {
        return evaluer(reservation, reservation.getProprietaire(), note, commentaire);
    }
    
    /**
     * VÃ©rifie si un utilisateur a dÃ©jÃ  Ã©valuÃ© une rÃ©servation.
     */
    public boolean aDejaEvalue(Utilisateur evaluateur, Reservation reservation) {
        return evaluations.stream()
                .anyMatch(e -> e.getEvaluateur().equals(evaluateur) && 
                        e.getReservationId().equals(reservation.getId()));
    }
    
    /**
     * Retourne les Ã©valuations reÃ§ues par un utilisateur.
     */
    public List<Evaluation> getEvaluationsRecues(Utilisateur utilisateur) {
        return evaluations.stream()
                .filter(e -> e.getEvaluer().equals(utilisateur))
                .collect(Collectors.toList());
    }
    
    /**
     * Retourne les Ã©valuations donnÃ©es par un utilisateur.
     */
    public List<Evaluation> getEvaluationsDonnees(Utilisateur utilisateur) {
        return evaluations.stream()
                .filter(e -> e.getEvaluateur().equals(utilisateur))
                .collect(Collectors.toList());
    }
    
    /**
     * Retourne les Ã©valuations d'une rÃ©servation.
     */
    public List<Evaluation> getEvaluationsReservation(Reservation reservation) {
        return evaluations.stream()
                .filter(e -> e.getReservationId().equals(reservation.getId()))
                .collect(Collectors.toList());
    }
    
    /**
     * Calcule la note moyenne d'un utilisateur.
     */
    public double calculerMoyenne(Utilisateur utilisateur) {
        List<Evaluation> evals = getEvaluationsRecues(utilisateur);
        if (evals.isEmpty()) {
            return 0.0;
        }
        return evals.stream()
                .mapToInt(Evaluation::getNote)
                .average()
                .orElse(0.0);
    }
    
    /**
     * Affiche un rÃ©sumÃ© des Ã©valuations d'un utilisateur.
     */
    public String getResumeEvaluations(Utilisateur utilisateur) {
        List<Evaluation> evals = getEvaluationsRecues(utilisateur);
        if (evals.isEmpty()) {
            return "Aucune Ã©valuation pour le moment";
        }
        
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("ğŸ“Š %s - %.1fâ˜… (%d avis)\n", 
                utilisateur.getNomComplet(),
                utilisateur.getReputation(),
                evals.size()));
        
        // Distribution des notes
        int[] distribution = new int[5];
        for (Evaluation eval : evals) {
            distribution[eval.getNote() - 1]++;
        }
        
        for (int i = 4; i >= 0; i--) {
            sb.append(String.format("   %dâ˜…: %d avis\n", i + 1, distribution[i]));
        }
        
        return sb.toString();
    }
    
    /**
     * GÃ©nÃ¨re un ID unique pour une Ã©valuation.
     */
    private String genererIdEvaluation() {
        return "EVAL-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();
    }
    
    public List<Evaluation> getEvaluations() {
        return evaluations;
    }
    
    public int getNombreEvaluations() {
        return evaluations.size();
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/factory/AnnonceFactory.java
package com.campusshare.factory;

import com.campusshare.model.Categorie;
import com.campusshare.model.Utilisateur;
import com.campusshare.model.annonce.*;

import java.util.UUID;

/**
 * Factory pour la crÃ©ation d'annonces.
 * 
 * Pattern Simple Factory: centralise la logique de crÃ©ation des diffÃ©rents
 * types d'annonces (Bien, Service, Don) dans une seule classe.
 * 
 * Avantages:
 * - Encapsule la logique de crÃ©ation complexe
 * - Le code client n'a pas besoin de connaÃ®tre les classes concrÃ¨tes
 * - Facilite l'ajout de nouveaux types d'annonces
 * - Point unique pour la gÃ©nÃ©ration des IDs et l'initialisation
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class AnnonceFactory {
    
    /**
     * CrÃ©e une annonce du type spÃ©cifiÃ©.
     * 
     * @param type Le type d'annonce Ã  crÃ©er
     * @param titre Titre de l'annonce
     * @param description Description dÃ©taillÃ©e
     * @param proprietaire Utilisateur propriÃ©taire
     * @param categorie CatÃ©gorie de l'annonce
     * @return L'annonce crÃ©Ã©e
     * @throws IllegalArgumentException si le type est inconnu
     */
    public static Annonce creerAnnonce(TypeAnnonce type, String titre, String description,
                                       Utilisateur proprietaire, Categorie categorie) {
        
        // T2-02: Validation de base (le titre ne peut pas Ãªtre vide)
        if (titre == null || titre.trim().isEmpty()) {
            throw new IllegalArgumentException("Le titre de l'annonce ne peut pas Ãªtre vide.");
        }

        String id = genererIdUnique(type);
        
        switch (type) {
            case BIEN:
                BienAnnonce bienAnnonce = new BienAnnonce(id, titre, description, 
                        proprietaire, categorie);
                System.out.println("ğŸ“¦ CrÃ©ation d'une annonce de BIEN: " + titre);
                return bienAnnonce;
                
            case SERVICE:
                ServiceAnnonce serviceAnnonce = new ServiceAnnonce(id, titre, description, 
                        proprietaire, categorie);
                System.out.println("ğŸ› ï¸ CrÃ©ation d'une annonce de SERVICE: " + titre);
                return serviceAnnonce;
                
            case DON:
                DonAnnonce donAnnonce = new DonAnnonce(id, titre, description, 
                        proprietaire, categorie);
                System.out.println("ğŸ CrÃ©ation d'une annonce de DON: " + titre);
                return donAnnonce;
                
            default:
                throw new IllegalArgumentException("Type d'annonce inconnu: " + type);
        }
    }
    
    /**
     * CrÃ©e une annonce de type Bien avec des paramÃ¨tres supplÃ©mentaires.
     * 
     * @param titre Titre de l'annonce
     * @param description Description dÃ©taillÃ©e
     * @param proprietaire Utilisateur propriÃ©taire
     * @param categorie CatÃ©gorie de l'annonce
     * @param etat Ã‰tat du bien
     * @param prixBase Prix de base (par jour gÃ©nÃ©ralement)
     * @return L'annonce de bien crÃ©Ã©e
     */
    public static BienAnnonce creerAnnonceBien(String titre, String description,
                                                Utilisateur proprietaire, Categorie categorie,
                                                String etat, double prixBase) {
        BienAnnonce annonce = (BienAnnonce) creerAnnonce(TypeAnnonce.BIEN, titre, 
                description, proprietaire, categorie);
        annonce.setEtat(etat);
        annonce.setPrixBase(prixBase);
        return annonce;
    }
    
    /**
     * CrÃ©e une annonce de type Service avec des paramÃ¨tres supplÃ©mentaires.
     * 
     * @param titre Titre de l'annonce
     * @param description Description dÃ©taillÃ©e
     * @param proprietaire Utilisateur propriÃ©taire
     * @param categorie CatÃ©gorie de l'annonce
     * @param typeService Type de service proposÃ©
     * @param prixBase Prix de base (par heure gÃ©nÃ©ralement)
     * @param dureeMinutes DurÃ©e estimÃ©e en minutes
     * @return L'annonce de service crÃ©Ã©e
     */
    public static ServiceAnnonce creerAnnonceService(String titre, String description,
                                                      Utilisateur proprietaire, Categorie categorie,
                                                      String typeService, double prixBase, 
                                                      int dureeMinutes) {
        ServiceAnnonce annonce = (ServiceAnnonce) creerAnnonce(TypeAnnonce.SERVICE, titre, 
                description, proprietaire, categorie);
        annonce.setTypeService(typeService);
        annonce.setPrixBase(prixBase);
        annonce.setDureeMinutesEstimee(dureeMinutes);
        return annonce;
    }
    
    /**
     * CrÃ©e une annonce de type Don avec des paramÃ¨tres supplÃ©mentaires.
     * 
     * @param titre Titre de l'annonce
     * @param description Description dÃ©taillÃ©e
     * @param proprietaire Utilisateur propriÃ©taire
     * @param categorie CatÃ©gorie de l'annonce
     * @param etatObjet Ã‰tat de l'objet donnÃ©
     * @param raisonDon Raison du don
     * @return L'annonce de don crÃ©Ã©e
     */
    public static DonAnnonce creerAnnonceDon(String titre, String description,
                                              Utilisateur proprietaire, Categorie categorie,
                                              String etatObjet, String raisonDon) {
        DonAnnonce annonce = (DonAnnonce) creerAnnonce(TypeAnnonce.DON, titre, 
                description, proprietaire, categorie);
        annonce.setEtatObjet(etatObjet);
        annonce.setRaisonDon(raisonDon);
        return annonce;
    }
    
    /**
     * GÃ©nÃ¨re un identifiant unique pour une annonce.
     * Format: TYPE-UUID (ex: BIEN-a1b2c3d4)
     * 
     * @param type Type d'annonce
     * @return Identifiant unique
     */
    private static String genererIdUnique(TypeAnnonce type) {
        String uuid = UUID.randomUUID().toString().substring(0, 8);
        return type.name() + "-" + uuid;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/paiement/PaiementCarteSimule.java
package com.campusshare.paiement;

import com.campusshare.model.Etudiant;
import com.campusshare.model.Transaction;
import java.util.Random;

/**
 * StratÃ©gie de paiement par carte bancaire simulÃ©e.
 * Cette stratÃ©gie simule un paiement par carte bancaire sans vÃ©ritable intÃ©gration bancaire.
 * UtilisÃ©e pour les achats nÃ©cessitant une transaction monÃ©taire rÃ©elle.
 *
 * Pattern: Strategy Pattern #1 (Finance & Paiements)
 *
 * Note: Il s'agit d'une simulation Ã  des fins Ã©ducatives. Dans un systÃ¨me rÃ©el,
 * cette classe intÃ©grerait une API de paiement (Stripe, PayPal, etc.).
 *
 * @author Equipe CampusShare - Member 3
 * @version 1.0
 */
public class PaiementCarteSimule implements IPaiementStrategy {

    private Random random;
    private static final double TAUX_REUSSITE = 0.95; // 95% de rÃ©ussite simulÃ©e

    /**
     * Constructeur de la stratÃ©gie de paiement par carte.
     */
    public PaiementCarteSimule() {
        this.random = new Random();
    }

    /**
     * Effectue un paiement par carte bancaire simulÃ©.
     * Simule une connexion Ã  une plateforme de paiement externe.
     *
     * @param montant Le montant en euros Ã  payer
     * @param emetteur L'Ã©tudiant qui paie (acheteur)
     * @param receveur L'Ã©tudiant qui reÃ§oit (vendeur)
     * @return true si le paiement a rÃ©ussi, false sinon
     */
    @Override
    public boolean payer(double montant, Etudiant emetteur, Etudiant receveur) {
        System.out.println("[PAIEMENT CARTE BANCAIRE] Simulation de paiement");
        System.out.println("â†’ Acheteur: " + emetteur.getNomComplet());
        System.out.println("â†’ Vendeur: " + receveur.getNomComplet());
        System.out.println("â†’ Montant: " + String.format("%.2f", montant) + " EUR");

        // Simulation de la connexion Ã  une API de paiement
        System.out.println("â†’ Connexion Ã  la plateforme de paiement...");

        boolean paiementReussi = simulerPaiementCB();

        if (paiementReussi) {
            String numeroAutorisation = genererNumeroAutorisation();
            System.out.println("âœ“ Paiement autorisÃ© - Code: " + numeroAutorisation);
            System.out.println("âœ“ Fonds transfÃ©rÃ©s avec succÃ¨s");

            // Dans un systÃ¨me rÃ©el, on crÃ©diterait le compte bancaire du vendeur
            // Ici, on peut optionnellement crÃ©diter des points bonus
            int pointsBonus = calculerPointsBonus(montant);
            if (pointsBonus > 0) {
                receveur.crediterPoints(pointsBonus);
                System.out.println("â†’ Bonus: " + pointsBonus + " points crÃ©ditÃ©s au vendeur");
            }

            return true;
        } else {
            System.out.println("âœ— ECHEC: Paiement refusÃ© par la banque");
            System.out.println("â†’ Raison: Simulation d'Ã©chec alÃ©atoire (fonds insuffisants, carte expirÃ©e, etc.)");
            return false;
        }
    }

    /**
     * Simule l'appel Ã  une API de paiement par carte bancaire.
     * Dans un systÃ¨me rÃ©el, cette mÃ©thode appellerait l'API de Stripe, PayPal, etc.
     *
     * @return true si le paiement est acceptÃ©, false sinon
     */
    private boolean simulerPaiementCB() {
        // Simulation d'un dÃ©lai de traitement
        try {
            Thread.sleep(100); // 100ms pour simuler la latence rÃ©seau
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        // Simulation d'un taux de rÃ©ussite de 95%
        return random.nextDouble() < TAUX_REUSSITE;
    }

    /**
     * GÃ©nÃ¨re un numÃ©ro d'autorisation de paiement fictif.
     *
     * @return Le numÃ©ro d'autorisation
     */
    private String genererNumeroAutorisation() {
        int numero = 100000 + random.nextInt(900000);
        return "AUTH-" + numero;
    }

    /**
     * Calcule les points bonus Ã  attribuer au vendeur en fonction du montant.
     * 1 point pour chaque tranche de 10 euros.
     *
     * @param montant Le montant de la transaction
     * @return Le nombre de points bonus
     */
    private int calculerPointsBonus(double montant) {
        return (int)(montant / 10);
    }

    /**
     * Valide un paiement par carte pour une transaction donnÃ©e.
     * Dans un systÃ¨me rÃ©el, cette mÃ©thode vÃ©rifierait le statut auprÃ¨s de la banque.
     *
     * @param transaction La transaction Ã  valider
     * @return true si la validation a rÃ©ussi, false sinon
     */
    @Override
    public boolean validerPaiement(Transaction transaction) {
        System.out.println("[VALIDATION] VÃ©rification du paiement par carte...");
        System.out.println("â†’ Transaction: " + transaction.getReference());
        System.out.println("â†’ Montant: " + String.format("%.2f", transaction.getMontant()) + " EUR");

        // Simulation de validation (toujours vraie une fois le paiement effectuÃ©)
        boolean valide = true;

        if (valide) {
            System.out.println("âœ“ Paiement validÃ© par la banque");
        } else {
            System.out.println("âœ— Paiement non validÃ©");
        }

        return valide;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/paiement/PaiementGratuit.java
package com.campusshare.paiement;

import com.campusshare.model.Etudiant;
import com.campusshare.model.Transaction;

/**
 * StratÃ©gie de paiement gratuit pour les dons et Ã©changes sans contrepartie financiÃ¨re.
 * Cette stratÃ©gie accepte toujours le paiement et ne dÃ©bite aucun compte.
 *
 * Pattern: Strategy Pattern #1 (Finance & Paiements)
 *
 * @author Equipe CampusShare - Member 3
 * @version 1.0
 */
public class PaiementGratuit implements IPaiementStrategy {

    /**
     * Effectue un "paiement" gratuit (toujours rÃ©ussi).
     * UtilisÃ© pour les dons et les Ã©changes gratuits.
     *
     * @param montant Le montant (ignorÃ©, devrait Ãªtre 0)
     * @param emetteur L'Ã©tudiant qui "paie" (donneur)
     * @param receveur L'Ã©tudiant qui reÃ§oit
     * @return true (toujours)
     */
    @Override
    public boolean payer(double montant, Etudiant emetteur, Etudiant receveur) {
        System.out.println("[PAIEMENT GRATUIT] Transaction gratuite acceptÃ©e");
        System.out.println("â†’ De: " + emetteur.getNomComplet());
        System.out.println("â†’ Vers: " + receveur.getNomComplet());
        System.out.println("â†’ Type: Don/Ã‰change gratuit");
        return true;
    }

    /**
     * Valide un paiement gratuit (toujours valide).
     *
     * @param transaction La transaction Ã  valider
     * @return true (toujours)
     */
    @Override
    public boolean validerPaiement(Transaction transaction) {
        System.out.println("[VALIDATION] Paiement gratuit validÃ© pour transaction: " + transaction.getReference());
        return true;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/paiement/IPaiementStrategy.java
package com.campusshare.paiement;

import com.campusshare.model.Etudiant;
import com.campusshare.model.Transaction;

/**
 * Interface dÃ©finissant le contrat pour les stratÃ©gies de paiement.
 * ImplÃ©mente le pattern Strategy pour permettre diffÃ©rents modes de paiement.
 *
 * Pattern: Strategy Pattern #1 (Finance & Paiements)
 *
 * @author Equipe CampusShare - Member 3
 * @version 1.0
 */
public interface IPaiementStrategy {

    /**
     * Effectue un paiement entre deux Ã©tudiants.
     *
     * @param montant Le montant Ã  payer
     * @param emetteur L'Ã©tudiant qui paie
     * @param receveur L'Ã©tudiant qui reÃ§oit le paiement
     * @return true si le paiement a rÃ©ussi, false sinon
     */
    boolean payer(double montant, Etudiant emetteur, Etudiant receveur);

    /**
     * Valide un paiement pour une transaction donnÃ©e.
     *
     * @param transaction La transaction Ã  valider
     * @return true si la validation a rÃ©ussi, false sinon
     */
    boolean validerPaiement(Transaction transaction);
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/paiement/PaiementPoints.java
package com.campusshare.paiement;

import com.campusshare.model.Etudiant;
import com.campusshare.model.Transaction;

/**
 * StratÃ©gie de paiement par points campus.
 * Cette stratÃ©gie dÃ©bite les points de l'Ã©metteur et crÃ©dite le receveur.
 * Le paiement Ã©choue si l'Ã©metteur n'a pas assez de points.
 *
 * Pattern: Strategy Pattern #1 (Finance & Paiements)
 *
 * RÃ¨gles:
 * - Solde minimum requis: le montant exact
 * - Ã‰chec si l'Ã©tudiant a 0 points
 * - SuccÃ¨s si l'Ã©tudiant a 100 points ou plus (selon le montant)
 *
 * @author Equipe CampusShare - Member 3
 * @version 1.0
 */
public class PaiementPoints implements IPaiementStrategy {

    /**
     * Effectue un paiement par points entre deux Ã©tudiants.
     * DÃ©bite l'Ã©metteur et crÃ©dite le receveur si le solde est suffisant.
     *
     * @param montant Le montant en points Ã  payer
     * @param emetteur L'Ã©tudiant qui paie (sera dÃ©bitÃ©)
     * @param receveur L'Ã©tudiant qui reÃ§oit (sera crÃ©ditÃ©)
     * @return true si le paiement a rÃ©ussi, false sinon
     */
    @Override
    public boolean payer(double montant, Etudiant emetteur, Etudiant receveur) {
        System.out.println("[PAIEMENT POINTS] Tentative de paiement");
        System.out.println("â†’ Ã‰metteur: " + emetteur.getNomComplet() + " (Solde: " + emetteur.getSoldePoints() + " pts)");
        System.out.println("â†’ Receveur: " + receveur.getNomComplet() + " (Solde: " + receveur.getSoldePoints() + " pts)");
        System.out.println("â†’ Montant: " + (int)montant + " points");

        // VÃ©rification du solde
        if (!verifierSolde(emetteur, (int)montant)) {
            System.out.println("âœ— ECHEC: Solde insuffisant");
            return false;
        }

        // ExÃ©cution du transfert
        boolean debitReussi = emetteur.debiterPoints((int)montant);

        if (debitReussi) {
            receveur.crediterPoints((int)montant);
            System.out.println("âœ“ Transfert de " + (int)montant + " points rÃ©ussi");
            return true;
        }

        System.out.println("âœ— ECHEC: Impossible de dÃ©biter les points");
        return false;
    }

    /**
     * VÃ©rifie si l'Ã©tudiant a suffisamment de points pour effectuer le paiement.
     *
     * @param etudiant L'Ã©tudiant dont on vÃ©rifie le solde
     * @param montant Le montant requis
     * @return true si le solde est suffisant, false sinon
     */
    private boolean verifierSolde(Etudiant etudiant, int montant) {
        int solde = etudiant.getSoldePoints();

        // Cas spÃ©cifiques mentionnÃ©s dans les critÃ¨res d'acceptation
        if (solde == 0) {
            System.out.println("â†’ VÃ©rification: ECHEC (0 points disponibles)");
            return false;
        }

        if (solde >= montant) {
            System.out.println("â†’ VÃ©rification: OK (solde: " + solde + " >= requis: " + montant + ")");
            return true;
        }

        System.out.println("â†’ VÃ©rification: ECHEC (solde: " + solde + " < requis: " + montant + ")");
        return false;
    }

    /**
     * Valide un paiement par points pour une transaction donnÃ©e.
     *
     * @param transaction La transaction Ã  valider
     * @return true si la validation a rÃ©ussi, false sinon
     */
    @Override
    public boolean validerPaiement(Transaction transaction) {
        Etudiant emetteur = transaction.getEmetteur();
        int montant = (int)transaction.getMontant();

        boolean valide = verifierSolde(emetteur, montant);

        if (valide) {
            System.out.println("[VALIDATION] Paiement par points validÃ© pour transaction: " + transaction.getReference());
        } else {
            System.out.println("[VALIDATION] Paiement par points refusÃ©: solde insuffisant");
        }

        return valide;
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/strategy/TarifForfaitaire.java
package com.campusshare.strategy;

import java.time.Duration;

/**
 * StratÃ©gie de tarification forfaitaire (prix fixe).
 * Le prix est fixe quelle que soit la durÃ©e.
 * IdÃ©ale pour les services Ã  prestation unique (dÃ©mÃ©nagement, trajet covoiturage, etc.)
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class TarifForfaitaire implements StrategyTarification {
    
    /**
     * Calcule le prix forfaitaire (simplement le prix de base).
     * La durÃ©e n'affecte pas le prix.
     * 
     * @param prixBase Le forfait
     * @param duree IgnorÃ©e
     * @return Le prix forfaitaire
     */
    @Override
    public double calculerPrix(double prixBase, Duration duree) {
        return prixBase;
    }
    
    @Override
    public String getNom() {
        return "Tarif Forfaitaire";
    }
    
    @Override
    public String getDescription() {
        return "Prix fixe quelle que soit la durÃ©e - IdÃ©al pour prestations uniques";
    }
    
    @Override
    public String toString() {
        return "ğŸ’° " + getNom();
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/strategy/TarifJournalier.java
package com.campusshare.strategy;

import java.time.Duration;

/**
 * StratÃ©gie de tarification Ã  la journÃ©e.
 * IdÃ©ale pour la location de biens (vÃ©los, matÃ©riel, etc.)
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class TarifJournalier implements StrategyTarification {
    
    private double reductionSemaine; // RÃ©duction si >= 7 jours
    
    /**
     * Constructeur avec rÃ©duction personnalisÃ©e.
     * 
     * @param reductionSemaine Pourcentage de rÃ©duction pour les locations longues (0.0 Ã  1.0)
     */
    public TarifJournalier(double reductionSemaine) {
        this.reductionSemaine = reductionSemaine;
    }
    
    /**
     * Constructeur par dÃ©faut (20% de rÃ©duction pour une semaine).
     */
    public TarifJournalier() {
        this.reductionSemaine = 0.20; // 20% de rÃ©duction
    }
    
    /**
     * Calcule le prix: prix de base Ã— nombre de jours.
     * Applique une rÃ©duction si durÃ©e >= 7 jours.
     * Minimum 1 jour facturÃ©.
     * 
     * @param prixBase Prix de base par jour
     * @param duree DurÃ©e de la rÃ©servation
     * @return Prix total
     */
    @Override
    public double calculerPrix(double prixBase, Duration duree) {
        long jours = duree.toDays();
        if (jours < 1) jours = 1; // Minimum 1 jour
        
        double prixTotal = prixBase * jours;
        
        // RÃ©duction pour location longue durÃ©e
        if (jours >= 7) {
            prixTotal *= (1 - reductionSemaine);
        }
        
        return Math.round(prixTotal * 100.0) / 100.0; // Arrondi Ã  2 dÃ©cimales
    }
    
    @Override
    public String getNom() {
        return "Tarif Journalier";
    }
    
    @Override
    public String getDescription() {
        return String.format("Facturation Ã  la journÃ©e (-%d%% si >= 7 jours)", 
                (int)(reductionSemaine * 100));
    }
    
    public double getReductionSemaine() {
        return reductionSemaine;
    }
    
    public void setReductionSemaine(double reductionSemaine) {
        this.reductionSemaine = reductionSemaine;
    }
    
    @Override
    public String toString() {
        return "ğŸ“… " + getNom();
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/strategy/TarifHoraire.java
package com.campusshare.strategy;

import java.time.Duration;

/**
 * StratÃ©gie de tarification Ã  l'heure.
 * IdÃ©ale pour les services ponctuels (cours particuliers, aide, etc.)
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class TarifHoraire implements StrategyTarification {
    
    private double tauxHoraire; // Prix supplÃ©mentaire par heure au-delÃ  de la premiÃ¨re
    
    /**
     * Constructeur avec taux horaire personnalisÃ©.
     * 
     * @param tauxHoraire Prix par heure supplÃ©mentaire
     */
    public TarifHoraire(double tauxHoraire) {
        this.tauxHoraire = tauxHoraire;
    }
    
    /**
     * Constructeur par dÃ©faut (taux = prix de base).
     */
    public TarifHoraire() {
        this.tauxHoraire = 1.0; // Multiplicateur par dÃ©faut
    }
    
    /**
     * Calcule le prix: prix de base Ã— nombre d'heures Ã— taux.
     * Minimum 1 heure facturÃ©e.
     * 
     * @param prixBase Prix de base par heure
     * @param duree DurÃ©e de la rÃ©servation
     * @return Prix total
     */
    @Override
    public double calculerPrix(double prixBase, Duration duree) {
        long heures = duree.toHours();
        if (heures < 1) heures = 1; // Minimum 1 heure
        return prixBase * heures * tauxHoraire;
    }
    
    @Override
    public String getNom() {
        return "Tarif Horaire";
    }
    
    @Override
    public String getDescription() {
        return String.format("Facturation Ã  l'heure (taux: x%.1f)", tauxHoraire);
    }
    
    public double getTauxHoraire() {
        return tauxHoraire;
    }
    
    public void setTauxHoraire(double tauxHoraire) {
        this.tauxHoraire = tauxHoraire;
    }
    
    @Override
    public String toString() {
        return "â° " + getNom();
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/strategy/TarifGratuit.java
package com.campusshare.strategy;

import java.time.Duration;

/**
 * StratÃ©gie de tarification gratuite.
 * UtilisÃ©e pour les prÃªts solidaires entre Ã©tudiants et les dons.
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public class TarifGratuit implements StrategyTarification {
    
    /**
     * Le prix est toujours 0, quelle que soit la durÃ©e.
     * 
     * @param prixBase IgnorÃ©
     * @param duree IgnorÃ©e
     * @return Toujours 0.0
     */
    @Override
    public double calculerPrix(double prixBase, Duration duree) {
        return 0.0;
    }
    
    @Override
    public String getNom() {
        return "Gratuit";
    }
    
    @Override
    public String getDescription() {
        return "PrÃªt ou don gratuit - Partage solidaire entre Ã©tudiants";
    }
    
    @Override
    public String toString() {
        return "ğŸ†“ " + getNom();
    }
}
-e 

--- END OF FILE ---


File: src/main/java/com/campusshare/strategy/StrategyTarification.java
package com.campusshare.strategy;

import java.time.Duration;

/**
 * Interface Strategy pour le calcul du prix des rÃ©servations.
 * 
 * Pattern Strategy: permet de dÃ©finir une famille d'algorithmes de tarification,
 * de les encapsuler et de les rendre interchangeables.
 * 
 * Avantages:
 * - Facile d'ajouter de nouvelles stratÃ©gies sans modifier le code existant
 * - Le code client (Reservation) reste simple et ne connaÃ®t pas les dÃ©tails
 * - Respect du principe Open/Closed (ouvert Ã  l'extension, fermÃ© Ã  la modification)
 * 
 * @author Equipe CampusShare
 * @version 1.0
 */
public interface StrategyTarification {
    
    /**
     * Calcule le prix total d'une rÃ©servation.
     * 
     * @param prixBase Le prix de base de l'annonce
     * @param duree La durÃ©e de la rÃ©servation
     * @return Le prix total calculÃ©
     */
    double calculerPrix(double prixBase, Duration duree);
    
    /**
     * Retourne le nom de la stratÃ©gie de tarification.
     * 
     * @return Le nom descriptif de la stratÃ©gie
     */
    String getNom();
    
    /**
     * Retourne une description de la stratÃ©gie.
     * 
     * @return La description
     */
    String getDescription();
}
-e 

--- END OF FILE ---


File: ./FINANCE_PAIEMENTS_README.md
# ğŸ’³ Module Finance & Paiements - CampusShare

## Strategy Pattern #1 (Member 3)

Ce module implÃ©mente le systÃ¨me de paiement de l'application CampusShare en utilisant le **Strategy Pattern** pour permettre diffÃ©rents modes de paiement interchangeables.

---

## ğŸ“‹ Tickets ImplÃ©mentÃ©s

### âœ… T3-01: Interface IPaiementStrategy et PaiementGratuit
- **Interface**: `IPaiementStrategy` dÃ©finit le contrat pour toutes les stratÃ©gies de paiement
- **ImplÃ©mentation**: `PaiementGratuit` pour les dons et Ã©changes gratuits
- **CritÃ¨re d'acceptation**: âœ“ PaiementGratuit retourne toujours `true` et affiche un log

### âœ… T3-02: StratÃ©gies PaiementPoints et PaiementCarteSimule
- **PaiementPoints**: Paiement par points campus (monnaie virtuelle)
  - âœ“ Ã‰chec si l'Ã©tudiant a 0 points
  - âœ“ SuccÃ¨s si l'Ã©tudiant a 100 points ou plus (selon montant)
  - âœ“ DÃ©bite l'Ã©metteur et crÃ©dite le receveur

- **PaiementCarteSimule**: Simulation de paiement par carte bancaire
  - âœ“ Simulation d'API de paiement externe
  - âœ“ Taux de rÃ©ussite de 95%
  - âœ“ Attribution de points bonus au vendeur (1 point / 10â‚¬)

### âœ… T3-03: ModÃ¨le Transaction et TransactionService
- **Transaction**: ModÃ¨le reprÃ©sentant une transaction financiÃ¨re
  - Associe une stratÃ©gie de paiement
  - GÃ¨re les statuts (EN_ATTENTE, VALIDE, REFUSE, ANNULE)
  - GÃ©nÃ¨re une rÃ©fÃ©rence unique

- **TransactionService**: Orchestration du flux de paiement complet
  - âœ“ Prend Annonce + Acheteur + StratÃ©gie
  - âœ“ ExÃ©cute le paiement
  - âœ“ CrÃ©e un enregistrement Transaction
  - âœ“ Met Ã  jour le solde de l'Ã©tudiant
  - âœ“ Marque l'annonce comme non disponible
  - âœ“ Historique des transactions

---

## ğŸ—ï¸ Architecture

```
com.campusshare/
â”œâ”€â”€ model/
â”‚   â”œâ”€â”€ Etudiant.java                    # HÃ©rite de Utilisateur, gÃ¨re les points
â”‚   â”œâ”€â”€ Transaction.java                 # ModÃ¨le de transaction
â”‚   â””â”€â”€ StatutTransaction.java           # Enum des statuts
â”œâ”€â”€ paiement/                            # Strategy Pattern
â”‚   â”œâ”€â”€ IPaiementStrategy.java           # Interface Strategy
â”‚   â”œâ”€â”€ PaiementGratuit.java            # StratÃ©gie pour dons
â”‚   â”œâ”€â”€ PaiementPoints.java             # StratÃ©gie par points
â”‚   â””â”€â”€ PaiementCarteSimule.java        # StratÃ©gie carte bancaire
â””â”€â”€ service/
    â””â”€â”€ TransactionService.java          # Orchestration des transactions
```

---

## ğŸ¯ Design Pattern: Strategy

Le **Strategy Pattern** permet de :
- DÃ©finir une famille d'algorithmes de paiement
- Encapsuler chaque algorithme dans une classe sÃ©parÃ©e
- Rendre les algorithmes interchangeables Ã  l'exÃ©cution

### Diagramme de classe simplifiÃ©

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  IPaiementStrategy      â”‚
                    â”‚  <<interface>>          â”‚
                    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                    â”‚ + payer()               â”‚
                    â”‚ + validerPaiement()     â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚              â”‚              â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ PaiementGratuit  â”‚    â”‚    â”‚ PaiementPoints     â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ + payer()        â”‚    â”‚    â”‚ + payer()          â”‚
      â”‚ + valider()      â”‚    â”‚    â”‚ + valider()        â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â”‚ - verifierSolde()  â”‚
                              â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ PaiementCarteSimule    â”‚
                    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                    â”‚ + payer()              â”‚
                    â”‚ + valider()            â”‚
                    â”‚ - simulerPaiementCB()  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’» Utilisation

### Exemple 1: Paiement Gratuit (Don)

```java
// CrÃ©ation des Ã©tudiants
Etudiant alice = new Etudiant("E001", "Martin", "Alice", ...);
Etudiant bob = new Etudiant("E002", "Dupont", "Bob", ...);

// CrÃ©ation d'une annonce de don
DonAnnonce don = new DonAnnonce(...);

// Paiement gratuit
IPaiementStrategy strategie = new PaiementGratuit();
TransactionService service = new TransactionService();
Transaction tx = service.effectuerTransaction(don, bob, strategie);
// â†’ RÃ©sultat: true (toujours)
```

### Exemple 2: Paiement par Points

```java
// CrÃ©ation d'une annonce
BienAnnonce velo = new BienAnnonce(...);
velo.setPrixBase(50.0); // 50 points

// Paiement par points
IPaiementStrategy strategie = new PaiementPoints();
Transaction tx = service.effectuerTransaction(velo, acheteur, strategie);
// â†’ RÃ©sultat: true si acheteur.getSoldePoints() >= 50
//            false sinon
```

### Exemple 3: Paiement par Carte Bancaire

```java
// CrÃ©ation d'une annonce de service
ServiceAnnonce cours = new ServiceAnnonce(...);
cours.setPrixBase(25.0); // 25 EUR

// Paiement par carte
IPaiementStrategy strategie = new PaiementCarteSimule();
Transaction tx = service.effectuerTransaction(cours, acheteur, strategie);
// â†’ Simulation bancaire avec 95% de rÃ©ussite
// â†’ Points bonus crÃ©ditÃ©s au vendeur (2 points pour 25â‚¬)
```

---

## ğŸ§ª Tests

ExÃ©cuter les tests complets :

```bash
# Compilation
javac -d out -sourcepath src/main/java src/main/java/com/campusshare/TestPaiements.java

# ExÃ©cution
java -cp out com.campusshare.TestPaiements
```

### RÃ©sultats attendus

```
âœ“ T3-01: IPaiementStrategy & PaiementGratuit
  â†’ PaiementGratuit retourne toujours true

âœ“ T3-02: PaiementPoints
  â†’ Ã‰chec si Ã©tudiant a 0 points
  â†’ SuccÃ¨s si Ã©tudiant a >= 100 points

âœ“ T3-02: PaiementCarteSimule
  â†’ Simulation bancaire fonctionnelle

âœ“ T3-03: Transaction & TransactionService
  â†’ Flux complet validÃ©
  â†’ Historique enregistrÃ©
```

---

## ğŸ“Š Classes CrÃ©Ã©es

### ModÃ¨le
- **Etudiant** (extends Utilisateur)
  - `soldePoints: int` - Solde en points campus
  - `debiterPoints(int): boolean` - DÃ©bite les points
  - `crediterPoints(int): void` - CrÃ©dite les points

- **Transaction**
  - `id, dateTransaction, montant, statut, reference`
  - `executerTransac(): boolean` - ExÃ©cute la transaction
  - `annuler(): boolean` - Annule si EN_ATTENTE

- **StatutTransaction** (enum)
  - `EN_ATTENTE, VALIDE, REFUSE, ANNULE`

### StratÃ©gies de Paiement
- **IPaiementStrategy** (interface)
  - `payer(montant, emetteur, receveur): boolean`
  - `validerPaiement(transaction): boolean`

- **PaiementGratuit**
  - Pour les dons et Ã©changes gratuits
  - Retourne toujours `true`

- **PaiementPoints**
  - Monnaie virtuelle campus
  - VÃ©rifie le solde avant transfert
  - Transfert atomique (dÃ©bit + crÃ©dit)

- **PaiementCarteSimule**
  - Simulation d'API bancaire
  - Taux de rÃ©ussite: 95%
  - Points bonus: 1 pt / 10â‚¬

### Service
- **TransactionService**
  - `effectuerTransaction(annonce, acheteur, strategie): Transaction`
  - `getHistoriqueTransactions(): List<Transaction>`
  - `getTransactionsEtudiant(etudiant): List<Transaction>`
  - `afficherHistorique(): void`

---

## âœ¨ FonctionnalitÃ©s AvancÃ©es

### 1. GÃ©nÃ©ration de RÃ©fÃ©rences Uniques
Chaque transaction gÃ©nÃ¨re une rÃ©fÃ©rence unique :
```
Format: TXN-[DATE]-[UUID]
Exemple: TXN-20251204162525-BD3B719F
```

### 2. Logs DÃ©taillÃ©s
Tous les paiements affichent des logs formatÃ©s :
```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   EXECUTION DE LA TRANSACTION TXN-...
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Emetteur: Alice Martin
Receveur: Bob Dupont
Montant: 50.0
StratÃ©gie: PaiementPoints
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
[PAIEMENT POINTS] Tentative de paiement
â†’ VÃ©rification: OK
âœ“ Transaction VALIDEE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### 3. Historique des Transactions
Le `TransactionService` maintient un historique complet :
- Liste chronologique de toutes les transactions
- Filtrage par Ã©tudiant
- Statistiques (montant total, nombre de transactions)

### 4. Points Bonus (Carte Bancaire)
Pour encourager les vendeurs, 1 point bonus est attribuÃ© pour chaque tranche de 10â‚¬ :
- 25â‚¬ â†’ 2 points bonus
- 100â‚¬ â†’ 10 points bonus

---

## ğŸ”„ Flux de Transaction Complet

```
1. CrÃ©ation de la transaction
   â””â”€> TransactionService.effectuerTransaction()

2. VÃ©rification
   â””â”€> Acheteur â‰  Vendeur
   â””â”€> Annonce disponible

3. ExÃ©cution du paiement
   â””â”€> Transaction.executerTransac()
   â””â”€> StratÃ©gie.payer(montant, emetteur, receveur)

4. Mise Ã  jour
   â””â”€> Soldes Ã©tudiants modifiÃ©s
   â””â”€> Annonce marquÃ©e indisponible
   â””â”€> Transaction enregistrÃ©e dans l'historique

5. Retour
   â””â”€> Transaction (ou null si Ã©chec)
```

---

## ğŸ“ Notes d'ImplÃ©mentation

### SÃ©curitÃ©
- VÃ©rification du solde avant dÃ©bit
- Transferts atomiques (rollback si Ã©chec partiel)
- Validation de l'Ã©metteur â‰  receveur

### ExtensibilitÃ©
Le pattern Strategy permet d'ajouter facilement de nouvelles mÃ©thodes :
- `PaiementPayPal`
- `PaiementStripe`
- `PaiementCrypto`
- etc.

Il suffit d'implÃ©menter `IPaiementStrategy` !

### Ã‰volutions Futures
- IntÃ©gration API bancaire rÃ©elle
- SystÃ¨me de remboursement
- Paiements en plusieurs fois
- Facturation automatique
- Notifications de paiement

---

## ğŸ‘¥ CrÃ©dits

**Member 3**: Finance & Payments (Strategy Pattern #1)
- Raouf HAOUCHINE (conception et implÃ©mentation)
- Date: 4 DÃ©cembre 2025
- Version: 1.0

---

## ğŸ“š RÃ©fÃ©rences

- **Design Pattern**: Strategy Pattern (GoF)
- **Projet**: CampusShare - Application de partage pour Ã©tudiants
- **Diagramme de classe**: Voir `diagramme_classes_campusshare_final.puml`
-e 

--- END OF FILE ---


File: ./docs/README.md
-e 

--- END OF FILE ---


File: ./README.md
# ğŸ“ CampusShare - Application de Partage Ã‰tudiant

## ğŸ“‹ Projet INFO 732

Application de partage de biens et services entre Ã©tudiants d'un campus universitaire.

---

## ğŸ¯ Objectif

Concevoir et rÃ©aliser une application permettant aux Ã©tudiants de :
- **Publier** des annonces (biens Ã  prÃªter/louer, services, dons)
- **Rechercher** et filtrer les annonces disponibles
- **RÃ©server** des biens ou services
- **Ã‰valuer** les autres utilisateurs aprÃ¨s une transaction

---

## ğŸ—ï¸ Design Patterns ImplÃ©mentÃ©s

### 1. ğŸ­ Simple Factory (`AnnonceFactory`)
**Objectif** : Centraliser la crÃ©ation des diffÃ©rents types d'annonces.

```java
// Utilisation
Annonce annonce = AnnonceFactory.creerAnnonce(TypeAnnonce.BIEN, titre, desc, user, cat);
```

**Avantages** :
- Encapsulation de la logique de crÃ©ation
- Le client ne connaÃ®t pas les classes concrÃ¨tes
- Facile d'ajouter de nouveaux types

### 2. ğŸ‘ï¸ Observer (`Observable` / `Observer`)
**Objectif** : Notifier automatiquement les utilisateurs lors de changements.

```java
// Attachement
annonce.attach(new EmailObserver(utilisateur));
annonce.attach(new PushObserver(utilisateur));

// Notification automatique
annonce.setPrixBase(newPrice); // DÃ©clenche notifyObservers()
```

**Avantages** :
- DÃ©couplage entre sujet et observateurs
- Ajout facile de nouveaux canaux (Email, Push, SMS)
- Abonnement/dÃ©sabonnement dynamique

### 3. ğŸ¯ Strategy (`StrategyTarification`)
**Objectif** : Permettre diffÃ©rents algorithmes de calcul de prix.

```java
// DiffÃ©rentes stratÃ©gies
Reservation r1 = service.reserverAvecTarifHoraire(annonce, user, debut, fin);
Reservation r2 = service.reserverAvecTarifJournalier(annonce, user, debut, fin);
Reservation r3 = service.reserverGratuit(annonce, user, debut, fin);
```

**StratÃ©gies disponibles** :
- `TarifGratuit` : PrÃªt solidaire gratuit
- `TarifHoraire` : Facturation Ã  l'heure
- `TarifJournalier` : Facturation Ã  la journÃ©e (avec rÃ©duction longue durÃ©e)
- `TarifForfaitaire` : Prix fixe

### 4. ğŸ”Œ Adapter (`GoogleCalendarAdapter`)
**Objectif** : IntÃ©grer des systÃ¨mes de calendrier externes.

```java
// Notre code utilise l'interface Calendrier
Calendrier cal = new GoogleCalendarAdapter(apiKey, calendarId);
cal.ajouterEvenement(reservation);

// L'adaptateur traduit vers l'API Google
```

**Avantages** :
- DÃ©couplage du code mÃ©tier et de l'API externe
- Facile de changer de fournisseur (Google â†’ Outlook)
- TestabilitÃ© amÃ©liorÃ©e

---

## ğŸ“ Structure du Projet

```
CampusShare/
â”œâ”€â”€ src/main/java/com/campusshare/
â”‚   â”œâ”€â”€ CampusShareApp.java          # Point d'entrÃ©e + dÃ©mo
â”‚   â”œâ”€â”€ model/
â”‚   â”‚   â”œâ”€â”€ Utilisateur.java
â”‚   â”‚   â”œâ”€â”€ Categorie.java
â”‚   â”‚   â”œâ”€â”€ Evaluation.java
â”‚   â”‚   â”œâ”€â”€ Reservation.java
â”‚   â”‚   â”œâ”€â”€ StatutAnnonce.java
â”‚   â”‚   â”œâ”€â”€ StatutReservation.java
â”‚   â”‚   â””â”€â”€ annonce/
â”‚   â”‚       â”œâ”€â”€ Annonce.java         # Classe abstraite
â”‚   â”‚       â”œâ”€â”€ BienAnnonce.java     # Bien Ã  prÃªter/louer
â”‚   â”‚       â”œâ”€â”€ ServiceAnnonce.java  # Service Ã  proposer
â”‚   â”‚       â”œâ”€â”€ DonAnnonce.java      # Don gratuit
â”‚   â”‚       â””â”€â”€ TypeAnnonce.java     # Enum
â”‚   â”œâ”€â”€ factory/
â”‚   â”‚   â””â”€â”€ AnnonceFactory.java      # Pattern Simple Factory
â”‚   â”œâ”€â”€ observer/
â”‚   â”‚   â”œâ”€â”€ Observable.java          # Interface Subject
â”‚   â”‚   â”œâ”€â”€ Observer.java            # Interface Observer
â”‚   â”‚   â”œâ”€â”€ EmailObserver.java
â”‚   â”‚   â”œâ”€â”€ PushObserver.java
â”‚   â”‚   â””â”€â”€ SMSObserver.java
â”‚   â”œâ”€â”€ strategy/
â”‚   â”‚   â”œâ”€â”€ StrategyTarification.java # Interface Strategy
â”‚   â”‚   â”œâ”€â”€ TarifGratuit.java
â”‚   â”‚   â”œâ”€â”€ TarifHoraire.java
â”‚   â”‚   â”œâ”€â”€ TarifJournalier.java
â”‚   â”‚   â””â”€â”€ TarifForfaitaire.java
â”‚   â”œâ”€â”€ adapter/
â”‚   â”‚   â”œâ”€â”€ Calendrier.java          # Interface cible
â”‚   â”‚   â”œâ”€â”€ GoogleCalendarAPI.java   # Classe adaptÃ©e
â”‚   â”‚   â””â”€â”€ GoogleCalendarAdapter.java # Adaptateur
â”‚   â””â”€â”€ service/
â”‚       â”œâ”€â”€ AnnonceService.java
â”‚       â”œâ”€â”€ ReservationService.java
â”‚       â””â”€â”€ EvaluationService.java
â””â”€â”€ docs/
    â”œâ”€â”€ diagrammes/
    â”‚   â”œâ”€â”€ classes.puml
    â”‚   â”œâ”€â”€ sequence_reservation.puml
    â”‚   â””â”€â”€ cas_utilisation.puml
    â””â”€â”€ README.md
```

---

## ğŸš€ Compilation et ExÃ©cution

### PrÃ©requis
- Java JDK 11 ou supÃ©rieur

### Compilation
```bash
# Linux/Mac
./compile.sh

# Windows
compile.bat

# Ou manuellement
mkdir -p target/classes
javac -d target/classes $(find src -name "*.java")
```

### ExÃ©cution
```bash
# Linux/Mac
./run.sh

# Windows
run.bat

# Ou manuellement
java -cp target/classes com.campusshare.CampusShareApp
```

---

## ğŸ“Š Diagrammes UML

Les diagrammes sont disponibles dans le dossier `docs/diagrammes/` au format PlantUML.

### Diagramme de Classes (simplifiÃ©)
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Utilisateur   â”‚     â”‚   Categorie     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - id            â”‚     â”‚ - id            â”‚
â”‚ - nom           â”‚     â”‚ - nom           â”‚
â”‚ - email         â”‚     â”‚ - description   â”‚
â”‚ - reputation    â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
         â”‚ 1                     â”‚ 1
         â”‚                       â”‚
         â–¼ *                     â–¼ *
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           <<abstract>>                  â”‚
â”‚             Annonce                     â”‚
â”‚           <<Observable>>                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - titre, description, prixBase          â”‚
â”‚ - statut, localisation                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ + attach(Observer)                      â”‚
â”‚ + detach(Observer)                      â”‚
â”‚ + notifyObservers(message)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â–¼           â–¼           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Bien   â”‚ â”‚ Service â”‚ â”‚   Don   â”‚
â”‚ Annonce â”‚ â”‚ Annonce â”‚ â”‚ Annonce â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Reservation   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ <<interface>>        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤         â”‚ StrategyTarification â”‚
â”‚ - dateDebut     â”‚         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - dateFin       â”‚         â”‚ + calculerPrix()     â”‚
â”‚ - prixTotal     â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                           â–¼           â–¼           â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ Gratuit  â”‚ â”‚ Horaire  â”‚ â”‚Journalierâ”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ‘¥ Ã‰quipe

Projet rÃ©alisÃ© dans le cadre du cours INFO 732.

---

## ğŸ“ Licence

Projet acadÃ©mique - Usage Ã©ducatif uniquement.
-e 

--- END OF FILE ---


--- DIRECTORY STRUCTURE ---

Source Tree:
src/main
â””â”€â”€ java
    â””â”€â”€ com
        â””â”€â”€ campusshare
            â”œâ”€â”€ CampusShareApp.java
            â”œâ”€â”€ TestPaiements.java
            â”œâ”€â”€ adapter
            â”‚Â Â  â”œâ”€â”€ Calendrier.java
            â”‚Â Â  â”œâ”€â”€ GoogleCalendarAPI.java
            â”‚Â Â  â””â”€â”€ GoogleCalendarAdapter.java
            â”œâ”€â”€ factory
            â”‚Â Â  â””â”€â”€ AnnonceFactory.java
            â”œâ”€â”€ model
            â”‚Â Â  â”œâ”€â”€ Categorie.java
            â”‚Â Â  â”œâ”€â”€ Etudiant.java
            â”‚Â Â  â”œâ”€â”€ Evaluation.java
            â”‚Â Â  â”œâ”€â”€ Reservation.java
            â”‚Â Â  â”œâ”€â”€ StatutAnnonce.java
            â”‚Â Â  â”œâ”€â”€ StatutReservation.java
            â”‚Â Â  â”œâ”€â”€ StatutTransaction.java
            â”‚Â Â  â”œâ”€â”€ Transaction.java
            â”‚Â Â  â”œâ”€â”€ Utilisateur.java
            â”‚Â Â  â””â”€â”€ annonce
            â”‚Â Â      â”œâ”€â”€ Annonce.java
            â”‚Â Â      â”œâ”€â”€ BienAnnonce.java
            â”‚Â Â      â”œâ”€â”€ DonAnnonce.java
            â”‚Â Â      â”œâ”€â”€ ServiceAnnonce.java
            â”‚Â Â      â””â”€â”€ TypeAnnonce.java
            â”œâ”€â”€ observer
            â”‚Â Â  â”œâ”€â”€ EmailObserver.java
            â”‚Â Â  â”œâ”€â”€ Observable.java
            â”‚Â Â  â”œâ”€â”€ Observer.java
            â”‚Â Â  â”œâ”€â”€ PushObserver.java
            â”‚Â Â  â””â”€â”€ SMSObserver.java
            â”œâ”€â”€ paiement
            â”‚Â Â  â”œâ”€â”€ IPaiementStrategy.java
            â”‚Â Â  â”œâ”€â”€ PaiementCarteSimule.java
            â”‚Â Â  â”œâ”€â”€ PaiementGratuit.java
            â”‚Â Â  â””â”€â”€ PaiementPoints.java
            â”œâ”€â”€ service
            â”‚Â Â  â”œâ”€â”€ AnnonceService.java
            â”‚Â Â  â”œâ”€â”€ EvaluationService.java
            â”‚Â Â  â”œâ”€â”€ ReservationService.java
            â”‚Â Â  â””â”€â”€ TransactionService.java
            â”œâ”€â”€ strategy
            â”‚Â Â  â”œâ”€â”€ StrategyTarification.java
            â”‚Â Â  â”œâ”€â”€ TarifForfaitaire.java
            â”‚Â Â  â”œâ”€â”€ TarifGratuit.java
            â”‚Â Â  â”œâ”€â”€ TarifHoraire.java
            â”‚Â Â  â””â”€â”€ TarifJournalier.java
            â””â”€â”€ test
                â””â”€â”€ TestAnnonceFeatures.java

13 directories, 39 files

Docs Tree:
docs
â”œâ”€â”€ README.md
â””â”€â”€ diagrammes
    â”œâ”€â”€ cas_utilisation.puml
    â”œâ”€â”€ classes.puml
    â”œâ”€â”€ sequence_observer.puml
    â”œâ”€â”€ sequence_reservation.puml
    â””â”€â”€ sequence_strategy.puml

2 directories, 6 files

---------------------------

Project Context: CampusShare - Student Exchange Platform
Course: INFO 732 (Design & Realization of Information Systems)

Core Concept: 
A desktop application allowing students to exchange goods (selling), services (tutoring), and donations. The project focuses strictly on Software Architecture and Design Patterns.

Technological Constraints:
- Language: Java (Standard Edition).
- UI: Console-based (System.out/System.in).
- Persistence: In-memory only (Data is lost on restart).

Architectural Requirements (Design Patterns):

1. Factory Pattern (Creational):
   - Location: `pattern.factory`
   - Role: Centralizes creation of advertisements (`Bien`, `Service`, `Don`).
   - Why: Encapsulates validation logic (e.g., Price must be 0 for Donations) and decouples the client from specific subclasses.

2. Observer Pattern (Behavioral):
   - Location: `pattern.observer`
   - Role: `Annonce` (Subject) notifies `Etudiant` (Observer).
   - Why: Users subscribe to ads. When an ad status changes (e.g., SOLD), subscribers are notified instantly without tight coupling.

3. Strategy Pattern (Behavioral) - Payment:
   - Location: `pattern.strategy`
   - Role: `IPaiementStrategy` defines how a transaction is processed.
   - Implementations: `PaiementPoints` (Virtual currency), `PaiementGratuit` (Donations), `PaiementCarteSimule`.

4. Strategy Pattern (Behavioral) - Search:
   - Location: `pattern.strategy`
   - Role: `ITriStrategy` defines sorting algorithms.
   - Implementations: Sort by Price, Sort by Date, Sort by Popularity.

5. Adapter Pattern (Structural):
   - Location: `pattern.adapter`
   - Role: Connects the internal `ICalendrier` interface to a (Mocked) External Google API.
   - Why: Allows the system to schedule exchanges on a calendar without depending directly on the external library's API structure.

Team Workflow:
- Member 1: Users & Observer Pattern.
- Member 2: Catalog & Factory Pattern.
- Member 3: Finance & Payment Strategy.
- Member 4: Search Strategy & Calendar Adapter.

